PK     ,}ÔH»ïŸ»í   í      __main__.pyimport sys

if sys.version_info[0] < 3:
	sys.exit("ok requires Python 3. \nFor more info: http://www-inst.eecs.berkeley.edu/~cs61a/fa14/lab/lab01/#installing-python")

from client.cli import ok

if __name__ == '__main__':
    ok.main()

PK     FIz~R†  †     client/exceptions.py"""Client exceptions."""


class OkException(BaseException):
    """Base exception class for OK."""


class AuthenticationException(OkException):
    """Exceptions related to authentication."""


class ProtocolException(OkException):
    """Exceptions related to protocol errors."""


# TODO(albert): extend from a base class designed for student bugs.
class Timeout(OkException):
    """Exception for timeouts."""
    _message = 'Evaluation timed out!'

    def __init__(self, timeout):
        """Constructor.

        PARAMTERS:
        timeout -- int; number of seconds before timeout error occurred
        """
        super().__init__(self)
        self.timeout = timeout
        self.message = self._message


class LoadingException(OkException):
    """Exception related to loading assignments."""


class SerializeException(LoadingException):
    """Exceptions related to de/serialization."""
PK     FI¾Õ²ëà   à      client/__init__.py__version__ = 'v1.6.14'

FILE_NAME = 'ok'

import os
import sys

sys.path.insert(0, '')
# Add directory in which the ok.zip is stored to sys.path.
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))
PK     Ü¥êHª¹ÕH©  ©     client/protocols/unlock.py"""Implements the UnlockProtocol, which unlocks all specified tests
associated with an assignment.

The UnlockTestCase interface can be implemented by TestCases that are
compatible with the UnlockProtocol.
"""

from client.protocols.common import models
from client.utils import auth
from client.utils import format
from client.utils import guidance
from client.utils import locking
from datetime import datetime
import logging
import random

log = logging.getLogger(__name__)

try:
    import readline
    HAS_READLINE = True
except ImportError:
    HAS_READLINE = False

class UnlockProtocol(models.Protocol):
    """Unlocking protocol that wraps that mechanism."""

    PROMPT = '? '       # Prompt that is used for user input.
    EXIT_INPUTS = (     # Valid user inputs for aborting the session.
        'exit()',
        'quit()',
    )

    def __init__(self, cmd_args, assignment):
        super().__init__(cmd_args, assignment)
        self.hash_key = assignment.name
        self.analytics = []
        self.access_token = None
        self.guidance_util = guidance.Guidance("", assignment=assignment)

    def run(self, messages):
        """Responsible for unlocking each test.

        The unlocking process can be aborted by raising a KeyboardInterrupt or
        an EOFError.

        RETURNS:
        dict; mapping of test name (str) -> JSON-serializable object. It is up
        to each test to determine what information is significant for analytics.
        """
        if self.args.export or not self.args.unlock:
            return
        if not self.args.local:
            self.access_token = auth.authenticate(False)

        format.print_line('~')
        print('Unlocking tests')
        print()

        print('At each "{}", type what you would expect the output to be.'.format(
              self.PROMPT))
        print('Type {} to quit'.format(self.EXIT_INPUTS[0]))
        print()

        for test in self.assignment.specified_tests:
            log.info('Unlocking test {}'.format(test.name))
            self.current_test = test.name

            try:
                test.unlock(self.interact)
            except (KeyboardInterrupt, EOFError):
                try:
                    # TODO(albert): When you use Ctrl+C in Windows, it
                    # throws two exceptions, so you need to catch both
                    # of them. Find a cleaner fix for this.
                    print()
                    print('-- Exiting unlocker --')
                except (KeyboardInterrupt, EOFError):
                    pass
                print()
                break
        messages['unlock'] = self.analytics

    def interact(self, unique_id, case_id, question_prompt, answer, choices=None, randomize=True):
        """Reads student input for unlocking tests until the student
        answers correctly.

        PARAMETERS:
        unique_id       -- str; the ID that is recorded with this unlocking
                           attempt.
        case_id         -- str; the ID that is recorded with this unlocking
                           attempt.
        question_prompt -- str; the question prompt
        answer          -- list; a list of locked lines in a test case answer.
        choices         -- list or None; a list of choices. If None or an
                           empty list, signifies the question is not multiple
                           choice.
        randomize       -- bool; if True, randomizes the choices on first
                           invocation.

        DESCRIPTION:
        Continually prompt the student for an answer to an unlocking
        question until one of the folliwng happens:

            1. The student supplies the correct answer, in which case
               the supplied answer is returned
            2. The student aborts abnormally (either by typing 'exit()'
               or using Ctrl-C/D. In this case, return None

        Correctness is determined by the verify method.

        RETURNS:
        list; the correct solution (that the student supplied). Each element
        in the list is a line of the correct output.
        """

        if randomize and choices:
            choices = random.sample(choices, len(choices))

        correct = False
        while not correct:
            if choices:
                assert len(answer) == 1, 'Choices must have 1 line of output'
                choice_map = self._display_choices(choices)

            question_timestamp = datetime.now()
            input_lines = []

            for line_number, line in enumerate(answer):
                if len(answer) == 1:
                    prompt = self.PROMPT
                else:
                    prompt = '(line {}){}'.format(line_number + 1, self.PROMPT)

                student_input = format.normalize(self._input(prompt))
                self._add_history(student_input)
                if student_input in self.EXIT_INPUTS:
                    raise EOFError

                if choices and student_input in choice_map:
                    student_input = choice_map[student_input]

                input_lines.append(student_input)
                if not self._verify(student_input, line):
                    # Try to evaluate student answer as Python expression and
                    # use the result as the answer.
                    try:
                        eval_input = repr(eval(student_input, {}, {}))
                        if not self._verify(eval_input, answer[line_number]):
                            break
                        # Replace student_input with evaluated input.
                        input_lines[-1] = eval_input
                    except Exception as e:
                        # Incorrect answer.
                        break

            else:
                correct = True
            tg_id = -1
            misU_count_dict = {}

            if not correct:
                misU_count_dict, tg_id, printed_msg = self.guidance_util.show_guidance_msg(unique_id,input_lines,
                    self.access_token, self.hash_key)

            else:
                print("-- OK! --")
                printed_msg = ["-- OK! --"]

            self.analytics.append({
                'id': unique_id,
                'case_id': case_id,
                'question timestamp': self.unix_time(question_timestamp),
                'answer timestamp': self.unix_time(datetime.now()),
                'prompt': question_prompt,
                'answer': input_lines,
                'correct': correct,
                'treatment group id': tg_id,
                'misU count': misU_count_dict,
                'printed msg': printed_msg
            })
            print()
        return input_lines

    ###################
    # Private Methods #
    ###################

    def _verify(self, guess, locked):
        return locking.lock(self.hash_key, guess) == locked

    def _input(self, prompt):
        """Retrieves user input from stdin."""
        return input(prompt)

    def _display_choices(self, choices):
        """Prints a mapping of numbers to choices and returns the
        mapping as a dictionary.
        """
        print("Choose the number of the correct choice:")
        choice_map = {}
        for i, choice in enumerate(choices):
            i = str(i)
            print('{}) {}'.format(i, format.indent(choice,
                                                   ' ' * (len(i) + 2)).strip()))
            choice = format.normalize(choice)
            choice_map[i] = choice
        return choice_map

    def _add_history(self, line):
        """Adds the given line to readline history, only if the line
        is non-empty.
        """
        if line and HAS_READLINE:
            readline.add_history(line)

    def unix_time(self, dt):
        """Returns the number of seconds since the UNIX epoch for the given
        datetime (dt).

        PARAMETERS:
        dt -- datetime
        """
        epoch = datetime.utcfromtimestamp(0)
        delta = dt - epoch
        return int(delta.total_seconds())

protocol = UnlockProtocol
PK     ,}ÔHòÄ“Ü	  	     client/protocols/scoring.py"""Implements the ScoringProtocol, which runs all specified tests
associated with an assignment.
"""

from client.sources.common import core
from client.sources.common import models as sources_models
from client.protocols.common import models as protocol_models
from client.utils import format
from collections import OrderedDict
import logging

log = logging.getLogger(__name__)

#####################
# Scoring Mechanism #
#####################

NO_PARTNER_NAME = 'Total'

class ScoringProtocol(protocol_models.Protocol):
    """A Protocol that runs tests, formats results, and reports a student's
    score.
    """
    def run(self, messages):
        """Score tests and print results

        Tests are taken from self.assignment.specified_tests. Each test belongs
        to a partner. If test.partner is omitted (i.e. core.NoValue), the score
        for that test is added to every partner's score.

        If there are no tests, the mapping will only contain one entry, mapping
        "Total" -> 0 (total score).

        If there are no partners specified by the tests, the mapping will only
        contain one entry, mapping "Total" (partner) -> total score (float).
        This assumes there is always at least one partner.
        """
        if self.args.export or not self.args.score:
            return

        format.print_line('~')
        print('Scoring tests')
        print()

        raw_scores = OrderedDict()
        for test in self.assignment.specified_tests:
            assert isinstance(test, sources_models.Test), 'ScoringProtocol received invalid test'

            log.info('Scoring test {}'.format(test.name))
            partner = test.partner if test.partner != core.NoValue else None
            raw_scores[test.name, partner] = (test.score(), test.points)

        messages['scoring'] =  display_breakdown(raw_scores, self.args.score_out)
        print()

def display_breakdown(scores, outfile):
    """Writes the point breakdown to outfile given a dictionary of scores.

    RETURNS:
    dict; maps partner (str) -> finalized score (float)
    """
    partner_totals = {}

    format.print_line('-')
    print('Point breakdown', file=outfile)
    for (name, partner), (score, total) in scores.items():
        print('    {}: {}/{}'.format(name, score, total), file=outfile)
        partner_totals[partner] = partner_totals.get(partner, 0) + score
    print(file=outfile)

    shared_points = partner_totals.get(None, 0)
    if None in partner_totals:
        del partner_totals[None]

    finalized_scores = {}
    print('Score:', file=outfile)
    if len(partner_totals) == 0:
        print('    {}: {}'.format(NO_PARTNER_NAME, shared_points), file=outfile)
        finalized_scores[NO_PARTNER_NAME] = shared_points
    else:
        for partner, score in sorted(partner_totals.items()):
            print('    Partner {}: {}'.format(partner, score + shared_points),
                  file=outfile)
            finalized_scores[partner] = score + shared_points
    outfile.flush()
    return finalized_scores

protocol = ScoringProtocol
PK     ,}ÔHYÒTSr  r     client/protocols/restore.pyfrom client.protocols.common import models
from client.utils import auth
from client.utils import network
from datetime import datetime
from urllib import error
import logging
import os
import shutil

log = logging.getLogger(__name__)

GAE_DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S.%f"

DEFAULT_BACKUP_DIR = "ok-backup"

class RestoreProtocol(models.Protocol):
    """Restores an assignment from an earlier backup."""

    def run(self, messages):
        """If the --restore flag is present, allow users to select
        a backup to restore from.
        """
        if not self.args.restore:
            return
        
        self.access_token = auth.authenticate(self.args.authenticate)
        
        print('Loading backups...')
        
        response = self.request('user')
        if not response:
            print('Could not connect to server.')
            return
        user = response['data']['results'][0]
        email = user['email'][0]
        assign_id = self.get_assign_id(self.assignment.endpoint)
        backups = self.get_backups(email, assign_id)
        current_time = datetime.now()
        print('0: Cancel Restore')
        for current in range(0, len(backups)):
            backup = backups[current]
            time_diff = get_time_diff(backup['timestamp'], current_time)
            print('{0}: {1} by {2}'.format(current + 1, time_diff, backup['submitter']))
        response = input('Backup #: ')
        selection = int(response) - 1
        if selection < 0 or selection >= len(backups):
            print("Invalid option for restoring backups.")
            return
        self.restore_backup(backups[selection])
        
    def restore_backup(self, backup):
        contents = backup['file_contents']
        backup_dir = find_backup_dir()
        os.makedirs(backup_dir)
        for filename in contents:
            if filename != 'submit':
                if os.path.exists(filename):
                    shutil.copyfile(filename, os.path.join(backup_dir, filename))
                with open(filename, "w+") as f:
                    f.write(contents[filename])
                    f.flush()
                    os.fsync(f.fileno())
        print("Restore complete.")
        print("Existing local files have been moved to '{0}'".format(backup_dir))
        
    def get_backups(self, email, assign_id):
        params = {
            'assignment': assign_id
        }
        response = self.request('user/{0}/get_backups'.format(email), params)
        backups = []
        for backup in response['data']:
            if 'file_contents' in backup['messages']:
                backups.append({
                    'file_contents': backup['messages']['file_contents'],
                    'submitter': backup['submitter']['email'][0],
                    'timestamp': datetime.strptime(backup['created'], GAE_DATETIME_FORMAT)
                })
        return backups
       
    def get_assign_id(self, endpoint):
        """Gets the assignment id for the given endpoint"""
        response = self.request('assignment')
        for assign in response['data']['results']:
            if assign['name'] == endpoint:
                return assign['id']
                
    def request(self, route, params={}):
        """Makes an API request"""
        return network.api_request(self.access_token, self.args.server, 
            route, self.args.insecure, params)
            
def get_time_diff(start, end):
    diff = end - start
    seconds = int(diff.total_seconds())
    minutes = seconds // 60
    hours = seconds // 3600
    days = seconds // 86400
    if seconds < 60:
        return '{0} seconds ago'.format(seconds)
    elif seconds < 3600:
        return '{0} minutes, {1} seconds ago'.format(minutes, seconds % 60)
    elif seconds < 86400:
        return '{0} hours, {1} minutes ago'.format(hours, minutes % 60)
    return '{0} days, {1} hours ago'.format(days, hours % 23)
    
def find_backup_dir():
    if not os.path.exists(DEFAULT_BACKUP_DIR):
        return DEFAULT_BACKUP_DIR
    counter = 1
    while os.path.exists(DEFAULT_BACKUP_DIR + str(counter)):
        counter += 1
    return DEFAULT_BACKUP_DIR + str(counter)

protocol = RestoreProtocol
PK     c·ÿH­;Oð5(  5(     client/protocols/hinting.py"""Implements the HintProtocol, which generates hints for students
that are stuck on a coding question. The protocol uses analytics
to determine whether a hint should be given and then
obtains them from the hint generation server. Free response questions
may be posed before and after hints are provided.
"""
from client.sources.common import core
from client.sources.common import models as sources_models
from client.protocols.common import models as protocol_models
from client.utils import auth
from client.utils import format

import json
import logging
import random
import socket
import urllib.error
import urllib.request

log = logging.getLogger(__name__)

#####################
# Hinting Mechanism #
#####################

class HintingProtocol(protocol_models.Protocol):
    """A protocol that provides rubber duck debugging and hints if applicable.
    """

    HINT_SERVER = "https://hinting.cs61a.org/"
    HINT_ENDPOINT = 'api/hints'
    SMALL_EFFORT = 2
    WAIT_ATTEMPTS = 5
    SUPPORTED_ASSIGNMENTS = ['cal/cs61a/su16/hw08', 'cal/cs61a/su16/lab10']

    def run(self, messages):
        """Determine if a student is elgible to recieve a hint. Based on their
        state, poses reflection questions.

        After more attempts, ask if students would like hints. If so, query
        the server.
        """
        if self.args.local:
            return

        # Only run hinting protocol on supported assignments.
        if self.assignment.endpoint not in self.SUPPORTED_ASSIGNMENTS:
            message = "{0} does not support hinting".format(self.assignment.endpoint)
            log.info(message)
            if self.args.hint:
                print(message)
            return

        if 'analytics' not in messages:
            log.info('Analytics Protocol is required for hint generation')
            return
        if 'file_contents' not in messages:
            log.info('File Contents needed to generate hints')
            return

        if self.args.no_hints:
            messages['hinting'] = {'disabled': 'user'}
            return

        messages['hinting'] = {}
        history = messages['analytics'].get('history', {})
        questions = history.get('questions', [])
        current_q = history.get('question', {})
        messages['hinting']['flagged'] = self.args.hint

        for question in current_q:
            if question not in questions:
                continue
            stats = questions[question]
            is_solved = stats['solved'] == True
            messages['hinting'][question] = {'prompts': {}, 'reflection': {}}
            hint_info = messages['hinting'][question]

            # Determine a users elgibility for a prompt

            # If the user just solved this question, provide a reflection prompt
            if is_solved:
                hint_info['elgible'] = False
                hint_info['disabled'] = 'solved'
                if self.args.hint:
                    print("This question has already been solved.")
                continue
            elif stats['attempts'] < self.SMALL_EFFORT:
                log.info("Question %s is not elgible: Attempts: %s, Solved: %s",
                         question, stats['attempts'], is_solved)
                hint_info['elgible'] = False
                if self.args.hint:
                    hint_info['disabled'] = 'attempt-count'
                    print("You need to make a few more attempts before the hint system is enabled")
                    continue
            else:
                # Only prompt every WAIT_ATTEMPTS attempts to avoid annoying user
                if stats['attempts'] % self.WAIT_ATTEMPTS != 0:
                    hint_info['disabled'] = 'timer'
                    hint_info['elgible'] = False
                    log.info('Waiting for %d more attempts before prompting',
                             stats['attempts'] % self.WAIT_ATTEMPTS)
                else:
                    hint_info['elgible'] = not is_solved

            if not self.args.hint:
                if hint_info['elgible']:
                    with format.block("-"):
                        print("To get hints, try using python3 ok --hint -q {}".format(question))
                    hint_info['suggested'] = True
                continue

            hint_info['accept'] = True

            with format.block("-"):
                print(("Thinking of a hint for {}".format(question) +
                       "... (This could take up to 30 seconds)"))
                pre_hint = random.choice(PRE_HINT_MESSAGES)
                print("In the meantime, consider: \n{}".format(pre_hint))
                hint_info['pre-prompt'] = pre_hint

                log.info('Prompting for hint on %s', question)
                try:
                    response = self.query_server(messages, question)
                except (urllib.error.URLError, urllib.error.HTTPError, socket.timeout):
                    log.debug("Network error while fetching hint", exc_info=True)
                    hint_info['fetch_error'] = True
                    print("\r\nNetwork Error while generating hint. Try again later")
                    response = None
                    continue

                if response:
                    hint_info['response'] = response

                    hint = response.get('message')
                    pre_prompt = response.get('pre-prompt')
                    post_prompt = response.get('post-prompt')
                    system_error = response.get('system-error')
                    log.info("Hint server response: {}".format(response))
                    if not hint:
                        if system_error:
                            print("{}".format(system_error))
                        else:
                            print("Sorry. No hints found for the current code. Try again making after some changes")
                        continue

                    # Provide padding for the the hint
                    print("\n{}".format(hint.rstrip()))

                    if post_prompt:
                        prompt_user(post_prompt, hint_info)

    def query_server(self, messages, test):
        access_token, _, _ = auth.get_storage()
        user = auth.get_student_email(access_token) or access_token
        if user:
            # The hinting server should not recieve identifying information
            user = hash(user)

        data = {
            'assignment': self.assignment.endpoint,
            'test': test,
            'messages': messages,
            'user': user
        }

        serialized_data = json.dumps(data).encode(encoding='utf-8')

        address = self.HINT_SERVER + self.HINT_ENDPOINT

        log.info('Sending hint request to %s', address)
        request = urllib.request.Request(address)
        request.add_header("Content-Type", "application/json")

        response = urllib.request.urlopen(request, serialized_data, 35)
        return json.loads(response.read().decode('utf-8'))

def prompt_user(query, results):
    try:
        response = None
        short_respones = 0
        while not response:
            response = input("{}\nYour Response: ".format(query))
            if not response or len(response) < 5:
                short_respones += 1
                # Do not ask more than twice to avoid annoying the user
                if short_respones > 2:
                    break
                print("Please enter at least a sentence.")
        results['prompts'][query] = response
        return response
    except KeyboardInterrupt:
        # Hack for windows:
        results['prompts'][query] = 'KeyboardInterrupt'
        try:
            print("Exiting Hint") # Second I/O will get KeyboardInterrupt
            return ''
        except KeyboardInterrupt:
            return ''

def confirm(message):
    response = input("{} [yes/no]: ".format(message))
    return response.lower() == "yes" or response.lower() == "y"


SOLVE_SUCCESS_MSG = [
    "If another student had the same error on this question, what advice would you give them?",
    "What did you learn from writing this program about things that you'll continue to do in the future?",
    "What difficulties did you encounter in understanding the problem?",
    "What difficulties did you encounter in designing the program?",
]

ps_strategies_messages = ("Which of the following problem solving strategies will you attempt next?\n"
"- Manually running the code against the test cases\n"
"- Drawing out the environment diagram\n"
"- Try to solve the problem in another programming language and then translating\n"
"- Ensuring that all of the types in the input/output of the function match the specification\n"
"- Solve a few of the test cases manually and then trying to find a pattern\n"
"- Using print statements/inspecting the value of variables to debug")

PRE_HINT_MESSAGES = [
    'Could you describe what the function you are working is supposed to do at a high level?',
    'It would be helpful if you could explain the error to the computer:', # Rubber duck
    'Try to create a hypothesis for how that output was produced. This output is produced because ...',
    'What is the simplest test that exposes this error?',
    ps_strategies_messages,
    'What type of value does the code output (a list, a number etc). ',
    'What type of value (a string, a number etc) does the test indicate is outputted?',
    'Are you convinced that the test case provided is correct?',
    'Describe how exactly the program behaves incorrectly?',
    'In two sentences or less, explain how the error/output is produced by the code in the function', # Rubber Duck
    'Are there lines that you suspect could be causing the program? Why those lines?',
    'Have you tried to use print statements? On what line of the program would a print statement be useful?',
    'Where is the last place you are sure your program was correct? How do you know?',
    'What lines(s) do you think could contain the bug, and why?',
    'What additional information do you need to find the bug? How should you generate this information?',
    "Do you believe that fixing this one test case will result in the program being correct? Why or Why Not?",
    ps_strategies_messages,
]


protocol = HintingProtocol
PK     ,}ÔHù ©ô¼	  ¼	     client/protocols/grading.py"""Implements the GradingProtocol, which runs all specified tests
associated with an assignment.

The GradedTestCase interface should be implemented by TestCases that
are compatible with the GradingProtocol.
"""

from client.protocols.common import models
from client.utils import format
import logging

log = logging.getLogger(__name__)

#####################
# Testing Mechanism #
#####################

class GradingProtocol(models.Protocol):
    """A Protocol that runs tests, formats results, and sends results
    to the server.
    """
    def run(self, messages):
        """Run gradeable tests and print results and return analytics.

        RETURNS:
        dict; a mapping of test name -> JSON-serializable object. It is up to
        each test to determine what kind of data it wants to return as
        significant for analytics. However, all tests must include the number
        passed, the number of locked tests and the number of failed tests.
        """
        if self.args.score or self.args.export or self.args.unlock or self.args.restore:
            return
        grade(self.assignment.specified_tests, messages, verbose=self.args.verbose)


def grade(questions, messages, env=None, verbose=True):
    format.print_line('~')
    print('Running tests')
    print()
    passed = 0
    failed = 0
    locked = 0

    analytics = {}
    # Check if analytics info is in messages.
    if 'analytics' in messages:
        started = messages['analytics']['started']
    else:
        started = None

    # The environment in which to run the tests.
    for test in questions:
        # run test if the question is not detected, or question detected and started
        if (started is None
            or test.name not in started
            or started[test.name]):

            log.info('Running tests for {}'.format(test.name))
            results = test.run(env)
            passed += results['passed']
            failed += results['failed']
            locked += results['locked']
            analytics[test.name] = results
        else:
            print('It looks like you haven\'t started {}. Skipping the tests.'.format(test.name))
            print()

        if not verbose and (failed > 0 or locked > 0):
            # Stop at the first failed test
            break

    format.print_progress_bar('Test summary', passed, failed, locked,
                              verbose=verbose)
    print()

    messages['grading'] = analytics

protocol = GradingProtocol
PK     ,}ÔH               client/protocols/__init__.pyPK     ,}ÔHåÀkÓç  ç     client/protocols/export.pyfrom client.protocols.common import models
from client.utils import auth
from client.utils import network
from datetime import datetime
from urllib import error
import logging
import os
import pickle

log = logging.getLogger(__name__)

GAE_DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S.%f"
EXPORT_CACHE = "export_cache.pkl"
SUBMISSION_DIR = "submissions"

class ExportProtocol(models.Protocol):
    """Downloads submissions from the server"""

    def run(self, messages):
        """If the --export parameter was used, downloads all submissions
        for the current assignment from the server and then exits
        """
        if not self.args.export:
            return

        self.access_token = auth.authenticate(self.args.authenticate)
        log.info('Authenticated with access token %s', self.access_token)

        data = None
        try:
            data = pickle.load(open(EXPORT_CACHE, "rb"))
        except IOError:
            data = {
                'endpoint': self.assignment.endpoint
            }
            data['assign'], data['course'] = self.get_ids(data['endpoint'])
            data['students'] = self.get_students(data['course'])
            if not data['students']:
                return
            data['current'] = 0

        current_student = 0
        try:
            if not os.path.exists(SUBMISSION_DIR):
                os.makedirs(SUBMISSION_DIR)

            downloads_left = len(data['students']) - data['current']

            print("{0} submissions left to download.".format(downloads_left))

            for current_student in range(data['current'], len(data['students'])):
                student = data['students'][current_student]
                try:
                    self.download_submission(student, data['assign'])
                except (IOError, error.HTTPError):
                    data['current'] = current_student
                    abort(data, len(data['students']), current_student)
                    return
                data['current'] = current_student + 1

        except KeyboardInterrupt:
            pickle.dump(data, open("export_cache.pkl", "wb"))
            abort(data, len(data['students']), current_student)
            return

        print("Submissions downloaded.")
        if os.path.exists(EXPORT_CACHE):
            os.remove(EXPORT_CACHE)

    def download_submission(self, student, assign_id):
        """Downloads a student's final submission for an assignment"""
        if self.args.latest:
            submission = self.get_latest_submission(student, assign_id)
        else:
            submission = self.get_final_submission(student, assign_id)
        if not submission:
            return
        contents, timestamp, subm_id = submission
        subm_dir = os.path.join(SUBMISSION_DIR, student[0])
        if not os.path.exists(subm_dir):
            os.makedirs(subm_dir)
        for filename in contents:
            if filename != 'submit':
                with open(os.path.join(subm_dir, filename), "w+") as f:
                    f.write(contents[filename])
                    f.flush()
                    os.fsync(f.fileno())

        with open(os.path.join(subm_dir, "info.py") , "w+") as f:
            f.write(r"info = {{'emails': {0}, 'submission_id': {1}, 'timestamp': '{2}' }}"
                .format(student, subm_id, timestamp))
            f.flush()
            os.fsync(f.fileno())

    def get_final_submission(self, student, assign_id):
        """Gets the final_submission from the server for use in download_submission"""
        params = {'assignment': assign_id}
        response = self.request('user/{0}/final_submission'.format(student[0]),
            params)
        if not response['data']:
            print("No final submission for {0}".format(student[0]))
            return
        raw_data = response['data']
        contents = raw_data['submission']['backup']['messages']['file_contents']
        timestamp = datetime.strptime(raw_data['submission']['backup']['server_time'], GAE_DATETIME_FORMAT)
        subm_id = raw_data['submission']['backup']['id']
        return contents, timestamp, subm_id

    def get_latest_submission(self, student, assign_id):
        """Gets the latest submission from the server for use in download_submission"""
        params = {'assignment': assign_id}
        data = self.request('user/{0}/get_submissions'.format(student[0]),
            params)['data']
        if len(data) == 0:
            print("No submissions for {0}".format(student[0]))
            return
        newest_time = None
        newest_subm = None
        for subm in data:
            time = datetime.strptime(subm['server_time'], GAE_DATETIME_FORMAT)
            if newest_time is None or time > newest_time:
                newest_time = time
                newest_subm = subm
        contents = newest_subm['backup']['messages']['file_contents']
        return contents, newest_time, newest_subm['id']

    def get_ids(self, endpoint):
        """Gets the course and assignment id for the given endpoint"""
        response = self.request('assignment')
        for assign in response['data']['results']:
            if assign['name'] == endpoint:
                return assign['id'], assign['course']['id']

    def request(self, route, params={}):
        """Makes an API request"""
        return network.api_request(self.access_token, self.args.server,
            route, self.args.insecure, params)

    def get_students(self, course):
        """Gets a list of students enrolled in the course"""
        response = self.request('course/{0}/get_students'.format(course),
            {"fields": '{"user":true}'})
        if not response:
            return
        return [student['user']['email'] for student in response['data']]

def abort(data, total_students, current_student):
    pickle.dump(data, open(EXPORT_CACHE, "wb"))
    dl_left = total_students - current_student
    print("Download failed. Run the following command to continue:")
    print("    python3 ok --export")
    print("{0} submissions left to download.".format(dl_left))

protocol = ExportProtocol
PK     ,}ÔH¥÷‚y  y  !   client/protocols/file_contents.pyfrom client.protocols.common import models
import logging
import os

log = logging.getLogger(__name__)

class FileContentsProtocol(models.Protocol):
    """The contents of source files are sent to the server."""

    def run(self, messages):
        """Find all source files and return their complete contents.

        Source files are considered to be files listed self.assignment.src.
        If a certain source filepath is not a valid file (e.g. does not exist
        or is not a file), then the contents associated with that filepath will
        be an empty string.

        RETURNS:
        dict; a mapping of source filepath -> contents as strings.
        """
        if self.args.export or self.args.restore:
            return
        
        files = {}
        # TODO(albert): move this to AnalyticsProtocol
        if self.args.submit:
            files['submit'] = True
        for file in self.assignment.src:
            if not self.is_file(file):
                # TODO(albert): add an error message
                contents = ''
                log.warning('File {} does not exist'.format(file))
            else:
                contents = self.read_file(file)
                log.info('Loaded contents of {} to send to server'.format(file))
            files[file] = contents

        messages['file_contents'] = files

    #####################
    # Mockable by tests #
    #####################

    def is_file(self, filepath):
        return os.path.isfile(filepath)

    def read_file(self, filepath):
        with open(filepath, 'r', encoding='utf-8') as lines:
            return lines.read()

protocol = FileContentsProtocol
PK     c·ÿH0›|  |     client/protocols/autostyle.pyfrom client.protocols.common import models
from client.utils import auth
import client

import json
import logging
import urllib.error
import urllib.request
import webbrowser

log = logging.getLogger(__name__)


class AutoStyleProtocol(models.Protocol):

    # Timeouts are specified in seconds.
    SHORT_TIMEOUT = 10
    API_ENDPOINT = '{prefix}://{server}'
    ALLOW_QUESTIONS = ['flatten', 'add_up', 'permutations']

    def run(self, messages):
        if not self.args.style:
            log.info("Autostyle not enabled.")
            return
        elif self.args.local:
            log.info("Autostyle requires network access.")
            return

        if not messages.get('analytics'):
            log.warning("Autostyle needs to be after analytics")
            return
        if not messages.get('grading'):
            log.warning("Autostyle needs to be after grading")
            return
        if not self.args.question:
            log.warning("Autostyle requires a specific question")
            return
        messages['autostyle'] = {}

        grading = messages['grading']

        if not self.args.question:
            log.info("-q flag was not specified")
            print("*" * 69)
            print("To use AutoStyle you must specify the -q flag!")
            print("*" * 69)
            return
        for question in self.args.question:
            if question in AutoStyleProtocol.ALLOW_QUESTIONS:
                # Ensure that all tests have passed
                results = grading.get(question)
                if not results:
                    log.warning("No grading info")
                    return
                elif results['failed'] or results['locked']:
                    log.warning("Has not passed all tests")
                    print("*" * 69)
                    print(
                        "To use AutoStyle you must have a correct solution for {0}!".format(question))
                    print("*" * 69)
                    return
            else:
                log.info("Not an autostyle question")
                print("*" * 69)
                print("Make sure the question you are using is an AutoStyle question!")
                print("*" * 69)
                return

        print("Once you begin you must finish the experiment in one sitting. This will take at most 2 hours.")
        confirm = input("Do you wish to continue to AutoStyle? (y/n): ")
        if confirm.lower().strip() != 'y':
            return

        messages['analytics']['identifier'] = auth.get_identifier()
        # Send data to autostyle
        response_url = self.send_messages(messages, self.SHORT_TIMEOUT)
        # Parse response_url
        if response_url:
            webbrowser.open_new(response_url)
        else:
            log.error("There was an error with AutoStyle. Please try again later!")

    def send_messages(self, messages, timeout):
        """Send messages to server, along with user authentication."""
        data = {
            'assignment': self.assignment.endpoint,
            'messages': messages,
            'submit': self.args.submit
        }
        serialized_data = json.dumps(data).encode(encoding='utf-8')
        server = 'codestyle.herokuapp.com/ok_launch/'
        address = self.API_ENDPOINT.format(server=server, prefix='http' if self.args.insecure else 'https')
        address_params = {
            'client_name': 'ok-client',
            'client_version': client.__version__,
        }
        address += '?'
        address += '&'.join('{}={}'.format(param, value) for param, value in address_params.items())

        log.info('Sending messages to %s', address)
        try:
            request = urllib.request.Request(address)
            request.add_header("Content-Type", "application/json")
            response = urllib.request.urlopen(request, serialized_data, timeout)
            response_dict = json.loads(response.read().decode('utf-8'))
            return response_dict['url']
        except (urllib.error.URLError, urllib.error.HTTPError,
                json.decoder.JSONDecodeError) as ex:
            log.warning('%s: %s', ex.__class__.__name__, str(ex))
        return

protocol = AutoStyleProtocol
PK     ,}ÔH&éÂ†       client/protocols/lock.pyfrom client.protocols.common import models
from client.utils import format
from client.utils import locking
import logging

log = logging.getLogger(__name__)

class LockProtocol(models.Protocol):
    """Locking protocol that wraps that mechanism."""

    name = 'lock'

    def run(self, messages):
        """Responsible for locking each test."""
        if not self.args.lock:
            return

        format.print_line('~')
        print('Locking tests')
        print()

        for test in self.assignment.test_map.values():
            log.info('Locking {}'.format(test.name))
            test.lock(self._hash_fn)

    def _hash_fn(self, text):
        text = format.normalize(text)
        return locking.lock(self.assignment.name, text)

protocol = LockProtocol
PK     c·ÿHVëà×Ž%  Ž%     client/protocols/backup.pyfrom client.protocols.common import models
from client.utils import auth
import client
import datetime
import json
import logging
import os
import pickle
import socket
import ssl
import urllib.error
import urllib.request

log = logging.getLogger(__name__)

class BackupProtocol(models.Protocol):

    # Timeouts are specified in seconds.
    SHORT_TIMEOUT = 2

    RETRY_LIMIT = 5
    BACKUP_FILE = ".ok_messages"
    BACKUP_ENDPOINT = '{prefix}://{server}/api/v3/backups/'
    REVISION_ENDPOINT = '{prefix}://{server}/api/v3/revision/'

    def run(self, messages):
        if self.args.local or self.args.export or self.args.restore:
            return

        if self.args.revise:
            action = 'Revise'
        elif self.args.submit:
            action = 'Submission'
        else:
            action = 'Backup'

        message_list = self.load_unsent_messages()

        access_token = auth.authenticate(False)
        log.info('Authenticated with access token %s', access_token)
        log.info('Sending unsent messages %s', access_token)

        if not access_token:
            print("Not authenticated. Cannot send {} to server".format(action))
            self.dump_unsent_messages(message_list)
            return

        # Messages from the current backup to send first
        is_send_first = self.args.submit or self.args.revise
        subm_messages = [messages] if is_send_first else []

        if is_send_first:
            response = self.send_all_messages(access_token, subm_messages,
                                              current=True)
            if message_list:
                self.send_all_messages(access_token, message_list,
                                       current=False)
        else:
            message_list.append(messages)
            response = self.send_all_messages(access_token, message_list,
                                              current=False)

        prefix = 'http' if self.args.insecure else 'https'
        base_url = '{0}://{1}'.format(prefix, self.args.server) + '/{}/{}/{}'

        if isinstance(response, dict):
            print('{action} successful for user: {email}'.format(action=action,
                        email=response['data']['email']))

            submission_type = 'submissions' if self.args.submit else 'backups'
            url = base_url.format(response['data']['assignment'],
                                  submission_type,
                                  response['data']['key'])

            if self.args.submit or self.args.backup:
                print('URL: {0}'.format(url))

            if self.args.backup:
                print('NOTE: this is only a backup. '
                      'To submit your assignment, use:\n'
                      '\tpython3 ok --submit')

        self.dump_unsent_messages(message_list + subm_messages)
        print()


    @classmethod
    def load_unsent_messages(cls):
        message_list = []
        try:
            with open(cls.BACKUP_FILE, 'rb') as fp:
                message_list = pickle.load(fp)
            log.info('Loaded %d backed up messages from %s',
                     len(message_list), cls.BACKUP_FILE)
        except (IOError, EOFError) as e:
            log.info('Error reading from ' + cls.BACKUP_FILE + \
                     ', assume nothing backed up')
        return message_list


    @classmethod
    def dump_unsent_messages(cls, message_list):
        with open(cls.BACKUP_FILE, 'wb') as f:
            log.info('Save %d unsent messages to %s', len(message_list),
                     cls.BACKUP_FILE)

            pickle.dump(message_list, f)
            os.fsync(f)


    def send_all_messages(self, access_token, message_list, current=False):
        if current and self.args.revise:
            action = "Revise"
        elif current and self.args.submit:
            action = "Submit"
        else:
            action = "Backup"

        num_messages = len(message_list)
        send_all = self.args.submit or self.args.backup
        retries = self.RETRY_LIMIT

        if send_all:
            timeout = None
            stop_time = datetime.datetime.max
            retries = self.RETRY_LIMIT * 2
        else:
            timeout = self.SHORT_TIMEOUT
            stop_time = datetime.datetime.now() + datetime.timedelta(seconds=timeout)
            log.info('Setting timeout to %d seconds', timeout)

        first_response = None
        error_msg = ''
        log.info("Sending {0} messages".format(num_messages))

        while retries > 0 and message_list and datetime.datetime.now() < stop_time:
            log.info('Sending messages...%d left', len(message_list))

            print('{action}... {percent}% complete'.format(action=action,
                percent=100 - round(len(message_list) * 100 / num_messages, 2)),
                end='\r')

            # message_list is assumed to be ordered in chronological order.
            # We want to send the most recent message first, and send older
            # messages after.
            message = message_list[-1]

            try:
                response = self.send_messages(access_token, message, timeout, current)
            except socket.timeout as ex:
                log.warning("socket.timeout: %s", str(ex))
                retries -= 1
                error_msg = 'Connection timed out after {} seconds. '.format(timeout) + \
                            'Please check your network connection.'
            except ssl.CertificateError as ex:
                log.warning("SSL Error: %s", str(ex))
                retries -= 1
                error_msg = 'SSL Verification Error: {}\n'.format(ex) + \
                            'Please check your network connection and SSL configuration.'
            except (urllib.error.URLError, urllib.error.HTTPError) as ex:
                log.warning('%s: %s', ex.__class__.__name__, str(ex))
                retries -= 1
                if not hasattr(ex, 'read'):
                    error_msg = 'Please check your network connection:\n{}'.format(ex)
                    continue

                try:
                    response_json = json.loads(ex.read().decode('utf-8'))
                except json.decoder.JSONDecodeError as ex:
                    log.warning("Invalid JSON Response", exc_info=True)
                    retries -= 1
                    error_msg = 'Invalid Server Error Response: {} \n'.format(ex) + \
                                'The server did not provide a valid response. Try again soon.'
                    continue

                log.warning('%s: %s', ex.__class__.__name__, str(ex))
                log.warning('%s error message: %s', ex.__class__.__name__,
                            response_json['message'])

                if ex.code == 403 and 'download_link' in response_json['data']:
                    retries = 0
                    error_msg = 'Aborting because OK may need to be updated.'
                else:
                    retries -= 1
                    error_msg = response_json['message']
            else:
                if not first_response:
                    first_response = response
                message_list.pop()

        if current and error_msg:
            print()     # Preserve progress bar.
            print('Could not', action.lower() + ':', error_msg)
        elif not message_list:
            print('{action}... 100% complete'.format(action=action))
            return first_response
        elif not send_all:
            # Do not display any error messages if --backup or --submit are not
            # used.
            print()
        elif not error_msg:
            # No errors occurred, but could not complete request within TIMEOUT.
            print()     # Preserve progress bar.
            print('Could not {} within {} seconds.'.format(action.lower(), timeout))
        else:
            # If not all messages could be backed up successfully.
            print()     # Preserve progress bar.
            print('Could not', action.lower() + ':', error_msg)

    def send_messages(self, access_token, messages, timeout, current):
        """Send messages to server, along with user authentication."""
        is_submit = current and self.args.submit and not self.args.revise
        is_revision = current and self.args.revise

        data = {
            'assignment': self.assignment.endpoint,
            'messages': messages,
            'submit': is_submit
        }
        serialized_data = json.dumps(data).encode(encoding='utf-8')

        if is_revision:
            address = self.REVISION_ENDPOINT.format(server=self.args.server,
                        prefix='http' if self.args.insecure else 'https')
        else:
            address = self.BACKUP_ENDPOINT.format(server=self.args.server,
                        prefix='http' if self.args.insecure else 'https')
        address_params = {
            'access_token': access_token,
            'client_name': 'ok-client',
            'client_version': client.__version__,
        }
        address += '?'
        address += '&'.join('{}={}'.format(param, value)
                            for param, value in address_params.items())

        redacted_address = address.replace(access_token, '*******')
        log.info('Sending messages to %s', redacted_address)

        request = urllib.request.Request(address)
        request.add_header("Content-Type", "application/json")

        response = urllib.request.urlopen(request, serialized_data, timeout)

        return json.loads(response.read().decode('utf-8'))

protocol = BackupProtocol
PK     c·ÿH­4Ó"Ô  Ô     client/protocols/analytics.py"""Implements the AnalyticsProtocol, which keeps track of configuration
for the ok grading session.
"""
import logging
import os
import pickle
import re

from client.protocols.common import models
from datetime import datetime

# TODO(albert): rename this InformationProtocol
# Add all command line arguments here

log = logging.getLogger(__name__)


class AnalyticsProtocol(models.Protocol):
    """A Protocol that analyzes how much students are using the autograder."""

    ANALYTICS_FILE = ".ok_history"

    RE_SNIPPET = re.compile(r"""
        \s*[\#\;]\s+BEGIN\s+(.*?)\n # \1 is question name
        (.*?)                       # \2 is the contents in between
        \s*[\#\;]\s+END\s+\1\n
        """, re.X | re.I | re.S)

    RE_DEFAULT_CODE = re.compile(r"""
    ^\"\*\*\*\sREPLACE\sTHIS\sLINE\s\*\*\*\"$
    """, re.X | re.I)

    RE_SCHEME_DEFAULT_CODE = re.compile(r"""
    ^\'REPLACE-THIS-LINE$
    """, re.X | re.I)

    RE_REPLACE_MARK = re.compile(r"""
            [\#\;][ ]Replace[ ]
            """, re.X | re.I | re.M)

    def run(self, messages):
        """Returns some analytics about this autograder run."""
        statistics = {}
        statistics['time'] = str(datetime.now())
        statistics['unlock'] = self.args.unlock

        if self.args.question:
            # TODO(denero) Get the canonical name of the question
            statistics['question'] = self.args.question

        statistics['started'] = self.check_start(messages['file_contents'])

        messages['analytics'] = statistics

        self.log_run(messages)

    def check_start(self, files):
        """Returns a dictionary where the key is question name, and the value
        signals whether the question has been started.
        """
        question_status = {}

        for path, lines in files.items():
            if not isinstance(lines, str):
                continue
            if len(lines) == 0:
                log.warning("File {0} has no content".format(path))

            snippets = self.RE_SNIPPET.findall(lines)

            for snippet in snippets:
                question_name = snippet[0]
                contents = snippet[1] if len(snippet) > 1 else None
                started = True

                if (contents != None
                    and ((self.RE_DEFAULT_CODE.match(contents.strip())
                         or self.RE_SCHEME_DEFAULT_CODE.match(contents.strip()))
                    or (not self.replaced(contents)))):
                    started = False

                if (question_name not in question_status
                    or (not question_status[question_name])):
                    question_status[question_name] = started

        return question_status

    def replaced(self, contents):
        """For a question snippet containing some default code, return True if the
        default code is replaced. Default code in a snippet should have
        '\# Replace with your solution' at the end of each line.
        """
        line_num = len(contents.strip(' ').splitlines())
        replace_marks = self.RE_REPLACE_MARK.findall(contents.strip())
        if len(replace_marks) == line_num:
            return False
        return True

    @classmethod
    def read_history(cls):
        history = {'questions': {}, 'all_attempts': 0}
        try:
            with open(cls.ANALYTICS_FILE, 'rb') as fp:
                history = pickle.load(fp)
            log.info('Loaded %d history from %s',
                     len(history), cls.ANALYTICS_FILE)
        except (IOError, EOFError) as e:
            log.info('Error reading from ' + cls.ANALYTICS_FILE + \
                     ', assume no history')
        return history

    def log_run(self, messages):
        """Record this run of the autograder to a local file.

        If the student does not specify what question(s) the student is
        running ok against, assume that the student is aiming to work on
        the question with the first failed test. If a student finishes
        questions 1 - N-1, the first test to fail will be N.
        """
        # Load the contents of the local analytics file
        history = self.read_history()
        history['all_attempts'] += 1

        # List of questions that the student asked to have graded
        questions = messages['analytics'].get('question', [])
        # The output of the grading protocol
        grading = messages.get('grading')

        # Attempt to figure out what the student is currently implementing
        if not questions and grading:
            # If questions are unspecified by the user, use the first failed test
            failed = first_failed_test(self.assignment.specified_tests, grading)

            logging.info('First failed test: %s', failed)
            if failed:
                history['question'] = [failed]

            # Update question correctness status from previous attempts
            for saved_q, details in history['questions'].items():
                finished = details['solved']
                if not finished and saved_q in grading:
                    scoring = grading[saved_q]
                    details['solved'] = is_correct(scoring)
        else:
            history['question'] = questions

        # Update attempt and correctness counts for the graded questions
        for question in questions:
            detail = history['questions']
            if grading and question in grading:
                scoring = is_correct(grading[question])
            else:
                scoring = False

            if question in history['questions']:
                q_info = detail[question]
                if grading and question in grading:
                    if q_info['solved'] != True:
                        q_info['solved'] = scoring
                    else:
                        continue # Already solved. Do not change total
                q_info['attempts'] += 1
            else:
                # Initialize this question info.
                detail[question] = {
                    'attempts': 1,
                    'solved': scoring
                }
            logging.info('Attempt %d for Question %s : %r',
                         history['questions'], question, scoring)

        with open(self.ANALYTICS_FILE, 'wb') as f:
            log.info('Saving history to %s', self.ANALYTICS_FILE)
            pickle.dump(history, f)
            os.fsync(f)

        messages['analytics']['history'] = history

def is_correct(grading_results):
    """The grading protocol provides grading_results, a dictionary which
    provides the count of tests passed, failed or locked for a single
    question. Return True if all tests have passed.
    """
    if grading_results['locked'] > 0:
        return False
    return sum(grading_results.values()) == grading_results['passed']

def first_failed_test(tests, scores):
    test_names = [t.name for t in tests]
    for test_name in test_names:
        scoring = scores.get(test_name, {})
        if test_name in scores and scoring.get('failed'):
            return test_name
    return None

protocol = AnalyticsProtocol
PK     ,}ÔH            #   client/protocols/common/__init__.pyPK     ,}ÔHL°  °  !   client/protocols/common/models.pyclass Protocol(object):
    """A Protocol encapsulates a single aspect of OK functionality."""

    def __init__(self, args, assignment):
        """Constructor.

        PARAMETERS:
        args       -- Namespace; parsed command line arguments by argparse.
        assignment -- dict; general information about the assignment.
        """
        self.args = args
        self.assignment = assignment

    def run(self, messages):
        """Executes the protocol, given a dictionary of messages.

        PARAMETERS:
        messages -- dict; a structure that Protocols can use to record data
                    and/or send to a server.
        """
        raise NotImplementedError

PK     ,}ÔHVAµæ#  æ#     client/api/assignment.pyfrom client import exceptions as ex
from client.sources.common import core
from client.utils import format
from client.protocols.grading import grade
import client
import collections
import glob
import importlib
import json
import logging
import os
import textwrap

log = logging.getLogger(__name__)

CONFIG_EXTENSION = '*.ok'

def load_assignment(filepath=None, cmd_args=None):
    config = _get_config(filepath)
    if not isinstance(config, dict):
        raise ex.LoadingException('Config should be a dictionary')
    if cmd_args is None:
        cmd_args = _MockNamespace()
    return Assignment(cmd_args, **config)

def _get_config(config):
    if config is None:
        configs = glob.glob(CONFIG_EXTENSION)
        if len(configs) > 1:
            raise ex.LoadingException('\n'.join([
                'Multiple .ok files found:',
                '    ' + ' '.join(configs),
                "Please specify a particular assignment's config file with",
                '    python3 ok --config <config file>'
            ]))
        elif not configs:
            raise ex.LoadingException('No .ok configuration file found')
        config = configs[0]
    elif not os.path.isfile(config):
        raise ex.LoadingException(
                'Could not find config file: {}'.format(config))

    try:
        with open(config, 'r') as f:
            result = json.load(f, object_pairs_hook=collections.OrderedDict)
    except IOError:
        raise ex.LoadingException('Error loading config: {}'.format(config))
    except ValueError:
        raise ex.LoadingException(
            '{0} is a malformed .ok configuration file. '
            'Please re-download {0}.'.format(config))
    else:
        log.info('Loaded config from {}'.format(config))
        return result


class Assignment(core.Serializable):
    name = core.String()
    endpoint = core.String()
    src = core.List(type=str, optional=True)
    tests = core.Dict(keys=str, values=str, ordered=True)
    default_tests = core.List(type=str, optional=True)
    protocols = core.List(type=str)

    ####################
    # Programmatic API #
    ####################

    def grade(self, question, env=None, skip_locked_cases=False):
        """Runs tests for a particular question. The setup and teardown will
        always be executed.

        question -- str; a question name (as would be entered at the command
                    line
        env      -- dict; an environment in which to execute the tests. If
                    None, uses the environment of __main__. The original
                    dictionary is never modified; each test is given a
                    duplicate of env.
        skip_locked_cases -- bool; if False, locked cases will be tested

        Returns: dict; maps question names (str) -> results (dict). The
        results dictionary contains the following fields:
        - "passed": int (number of test cases passed)
        - "failed": int (number of test cases failed)
        - "locked": int (number of test cases locked)
        """
        if env is None:
            import __main__
            env = __main__.__dict__
        messages = {}
        tests = self._resolve_specified_tests([question], all_tests=False)
        for test in tests:
            try:
                for suite in test.suites:
                    suite.skip_locked_cases = skip_locked_cases
                    suite.console.skip_locked_cases = skip_locked_cases
                    suite.console.hash_key = self.name
            except AttributeError:
                pass
        test_name = tests[0].name
        grade(tests, messages, env)
        return messages['grading'][test_name]

    ############
    # Internal #
    ############

    _TESTS_PACKAGE = 'client.sources'
    _PROTOCOL_PACKAGE = 'client.protocols'

    def __init__(self, args, **fields):
        self.cmd_args = args
        self.test_map = collections.OrderedDict()
        self.protocol_map = collections.OrderedDict()

    def post_instantiation(self):
        self._print_header()
        self._load_tests()
        self._load_protocols()
        self.specified_tests = self._resolve_specified_tests(
            self.cmd_args.question, self.cmd_args.all)

    def _load_tests(self):
        """Loads all tests specified by test_map."""
        log.info('Loading tests')
        for file_pattern, source in self.tests.items():
            # Separate filepath and parameter
            if ':' in file_pattern:
                file_pattern, parameter = file_pattern.split(':', 1)
            else:
                parameter = ''

            for file in sorted(glob.glob(file_pattern)):
                try:
                    module = importlib.import_module(self._TESTS_PACKAGE + '.' + source)
                except ImportError:
                    raise ex.LoadingException('Invalid test source: {}'.format(source))

                test_name = file
                if parameter:
                    test_name += ':' + parameter
                self.test_map.update(module.load(file, parameter, self))
                log.info('Loaded {}'.format(test_name))

        if not self.test_map:
            raise ex.LoadingException('No tests loaded')

    def dump_tests(self):
        """Dumps all tests, as determined by their .dump() method.

        PARAMETERS:
        tests -- dict; file -> Test. Each Test object has a .dump method
                 that takes a filename and serializes the test object.
        """
        log.info('Dumping tests')
        for test in self.test_map.values():
            try:
                test.dump()
            except ex.SerializeException as e:
                log.warning('Unable to dump {}: {}'.format(test.name, str(e)))
            else:
                log.info('Dumped {}'.format(test.name))

    def _resolve_specified_tests(self, questions, all_tests=False):
        """For each of the questions specified on the command line,
        find the test corresponding that question.

        Questions are preserved in the order that they are specified on the
        command line. If no questions are specified, use the entire set of
        tests.
        """
        if not questions and not all_tests \
                and self.default_tests != core.NoValue \
                and len(self.default_tests) > 0:
            log.info('Using default tests (no questions specified): '
                     '{}'.format(self.default_tests))
            return [self.test_map[test] for test in self.default_tests]
        elif not questions:
            log.info('Using all tests (no questions specified and no default tests)')
            return list(self.test_map.values())
        elif not self.test_map:
            log.info('No tests loaded')
            return []

        specified_tests = []
        for question in questions:
            if question not in self.test_map:
                print('Test "{}" not found.'.format(question))
                print('Did you mean one of the following? '
                      '(Names are case sensitive)')
                for test in self.test_map:
                    print('    {}'.format(test))
                raise ex.LoadingException('Invalid test specified: {}'.format(question))

            log.info('Adding {} to specified tests'.format(question))
            if question not in specified_tests:
                specified_tests.append(self.test_map[question])
        return specified_tests

    def _load_protocols(self):
        log.info('Loading protocols')
        for proto in self.protocols:
            try:
                module = importlib.import_module(self._PROTOCOL_PACKAGE + '.' + proto)
            except ImportError:
                raise ex.LoadingException('Invalid protocol: {}'.format(proto))

            self.protocol_map[proto] = module.protocol(self.cmd_args, self)
            log.info('Loaded protocol "{}"'.format(proto))

    def _print_header(self):
        format.print_line('=')
        print('Assignment: {}'.format(self.name))
        print('OK, version {}'.format(client.__version__))
        format.print_line('=')
        print()

class _MockNamespace(object):
    """A mock object that is meant to be a substitute for an argparse.Namespace
    object. This object contains the minimal set of fields necessary for an
    Assignment to be created.

    Do NOT use this for any command-line related work. This object should only
    be used for the programmatic API. This implies that if an Assignment is
    created with a MockNamespace, any functionality not specified in the
    programmatic API will not work.

    Design note: In an ideal world, this object wouldn't even exist and the
    Assignment and Protocol classes shouldn't take in an argparse.Namespace
    object. Instead, the Assignment class should be part of the API and should
    not be tied to command-line usage only. Making changes to this effect would
    take a substantial rewrite, so I'm putting it off for now.
    """
    def __init__(self):
        from client.cli.ok import parse_input
        self.args = parse_input([])

    def __getattr__(self, attr):
        return getattr(self.args, attr)
PK     ,}ÔH               client/api/__init__.pyPK     ,}ÔH               client/sources/__init__.pyPK     ,}ÔHù:kT    &   client/sources/scheme_test/__init__.pyfrom client import exceptions as ex
from client.sources.scheme_test import models
import os

def load(file, _, assign):
    """Loads Scheme tests from a specified filepath.

    PARAMETERS:
    file -- str; a filepath to a Scheme file.

    RETURNS:
    Test
    """
    if not os.path.isfile(file) or not file.endswith('.scm'):
        raise ex.LoadingException('Cannot run Scheme tests from {}'.format(file))

    with open(file, 'r') as f:
        file_contents = f.read()

    try:
        return {file: models.SchemeTest(file, file_contents, assign.cmd_args.timeout,
                                        name=file, points=1)}
    except ex.SerializeException:
        raise ex.LoadingException('Unable to load Scheme test '
                                  'from {}'.format(file))

PK     ,}ÔH»èÄ6
  
  $   client/sources/scheme_test/models.py"""Interprets Scheme test files and compares each line of printed output from
the read-eval-print loop and from any output functions to an expected output
described in a comment.  For example,

(display (+ 2 3))
; expect 5

Differences between printed and expected outputs are printed with line numbers.

Requires the following attributes from an importable scheme module:

    scheme.create_global_frame
    scheme.Buffer
    scheme.read_eval_print_loop
    scheme.tokenize_lines
"""

from client.sources.common import models
from client.utils import format
from client.utils import output
from client.utils import timer
import importlib
import re
import sys


##########
# Models #
##########

class SchemeTest(models.Test):

    def __init__(self, file, file_contents, timeout=None, **fields):
        super().__init__(**fields)
        self.file = file
        self.file_contents = file_contents
        self.timeout = timeout

    def run(self, env):
        """Runs the suites associated with this doctest.

        NOTE: env is intended only for use with the programmatic API to support
        Python OK tests. It is not used here.

        RETURNS:
        bool; True if the doctest completely passes, False otherwise.
        """
        format.print_line('-')
        print('Scheme tests in {}'.format(self.file))
        print()

        passed, failed = self._run_tests()

        print('{} passed; {} failed'.format(passed, failed))
        if failed == 0 and passed > 0:
            print('-- OK! --')
            print()

        return {'passed': passed, 'failed': failed, 'locked': 0}

    def score(self):
        format.print_line('-')
        print('Scheme tests in {}'.format(self.file))
        print()
        _, failed = self._run_tests()
        score = 1.0 if failed == 0 else 0.0

        print('Score: {}/1'.format(score))
        print()
        return score

    def unlock(self, interact):
        """Scheme tests cannot be unlocked."""

    def lock(self, hash_fn):
        """Scheme tests cannot be locked."""

    def dump(self):
        """Scheme tests do not need to be dumped, since no state changes."""

    ###############
    # Test runner #
    ###############

    def _run_tests(self):
        """Run a read-eval loop that reads from src_file and collects outputs."""
        if not self._import_scheme():
            return 0, 0

        output.off()
        reader = None
        try:
            reader = TestReader(self.file_contents.split('\n'))
            src = self.scheme.Buffer(self.scheme.tokenize_lines(reader))
            def next_line():
                src.current()
                if reader.line_number == len(reader.lines):
                    # No more lines in file.
                    raise EOFError
                return src
            timer.timed(self.timeout, self.scheme.read_eval_print_loop,
                        (next_line, self.scheme.create_global_frame()))
        except BaseException as e:
            output.on()
            if reader:
                print("Tests terminated due to unhandled exception "
                      "after line {}:\n"
                      "{}: {}".format(reader.line_number, e.__class__.__name__, e))
        output.on()

        if reader:
            return self._summarize(reader.output, reader.expected_output)
        return 0, 0

    def _summarize(self, output, expected_output):
        """Summarize results of running tests."""
        num_failed = 0

        def failed(expected, actual, line):
            nonlocal num_failed
            num_failed += 1
            print('test failed at line', line)
            print('  expected', expected)
            print('   printed', actual)

        for (actual, (expected, line_number)) in zip(output, expected_output):
            if expected.startswith("Error"):
                if not actual.startswith("Error"):
                    failed('an error indication', actual, line_number)
            elif actual != expected:
                failed(expected, actual, line_number)

        return len(expected_output) - num_failed, num_failed

    def _import_scheme(self):
        try:
            sys.path.insert(0, 'scheme')
            self.scheme = importlib.import_module('scheme')
        except ImportError as e:
            print('Could not import scheme')
            return False
        return True

###############
# Test reader #
###############

class TestReader:
    """A TestReader is an iterable that collects test case expected results."""

    EXPECT_PATTERN = re.compile(r'\s*;\s*expect\s*(.*)', re.I)

    def __init__(self, lines):
        self.lines = lines
        self.last_out_len = 0
        self.output = []
        self.expected_output = []
        self.line_number = 0

    def __iter__(self):
        log_id = output.new_log()
        output_log = output.get_log(log_id)

        for line in self.lines:
            self.line_number += 1
            match = self.EXPECT_PATTERN.match(line)
            if match:
                expected = match.group(1).split(';')
                for exp in expected:
                    self.expected_output.append((exp.strip(), self.line_number))
                # Split output based on newlines.
                output_lines = ''.join(output_log).split('\n')
                if len(output_lines) > self.last_out_len:
                    self.output.extend(output_lines[-1-len(expected):-1])
                else:
                    self.output.extend([''] * len(expected))
                self.last_out_len = len(output_lines)
            yield line

        output.remove_log(log_id)
        raise EOFError
PK     ,}ÔHOOöl•
  •
  "   client/sources/doctest/__init__.pyfrom client import exceptions as ex
from client.sources.common import importing
from client.sources.doctest import models
import logging
import os
import traceback

log = logging.getLogger(__name__)

def load(file, name, assign):
    """Loads doctests from a specified filepath.

    PARAMETERS:
    file -- str; a filepath to a Python module containing OK-style
            tests.
    name -- str; optional parameter that specifies a particular function in
            the file. If omitted, all doctests will be included.

    RETURNS:
    Test
    """
    if not os.path.isfile(file) or not file.endswith('.py'):
        raise ex.LoadingException('Cannot import doctests from {}'.format(file))

    try:
        module = importing.load_module(file)
    except Exception:
        # Assume that part of the traceback includes frames from importlib.
        # Begin printing the traceback after the last line involving importlib.
        # TODO(albert): Try to find a cleaner way to do this. Also, might want
        # to move this to a more general place.
        print('Traceback (most recent call last):')
        stacktrace = traceback.format_exc().split('\n')
        start = 0
        for i, line in enumerate(stacktrace):
            if 'importlib' in line:
                start = i + 1
        print('\n'.join(stacktrace[start:]))

        raise ex.LoadingException('Error importing file {}'.format(file))

    if name:
        return {name: _load_test(file, module, name, assign)}
    else:
        return _load_tests(file, module, assign)


def _load_tests(file, module, assign):
    tests = {}
    for name in dir(module):
        to_test = getattr(module, name)
        if callable(to_test) and to_test.__module__ == module.__name__:
            tests[name] = _load_test(file, module, name, assign)
    return tests

def _load_test(file, module, name, assign):
    namespace = module
    for attr in name.split('.'):
        if not hasattr(namespace, attr):
            raise ex.LoadingException('Module {} has no attribute {}'.format(
                module.__name__, name))
        namespace = getattr(namespace, attr)
    func = namespace

    if not callable(func):
        raise ex.LoadingException('Attribute {} is not a function'.format(name))

    docstring = func.__doc__ if func.__doc__ else ''
    try:
        return models.Doctest(file, assign.cmd_args.verbose, assign.cmd_args.interactive,
                              assign.cmd_args.timeout, name=name, points=1,
                              docstring=docstring)
    except ex.SerializeException:
        raise ex.LoadingException('Unable to load doctest for {} '
                                  'from {}'.format(name, file))

PK     ,}ÔHžZÉ  É      client/sources/doctest/models.pyfrom client import exceptions as ex
from client.sources.common import core
from client.sources.common import importing
from client.sources.common import interpreter
from client.sources.common import models
from client.sources.common import pyconsole
from client.utils import format
from client.utils import output
import re
import textwrap

##########
# Models #
##########

class Doctest(models.Test):
    docstring = core.String()

    PS1 = '>>> '
    PS2 = '... '

    SETUP = PS1 + 'from {} import *'
    prompt_re = re.compile(r'(\s*)({}|{})'.format(PS1, '\.\.\. '))

    def __init__(self, file, verbose, interactive, timeout=None, **fields):
        super().__init__(**fields)
        self.file = file
        self.verbose = verbose
        self.interactive = interactive
        self.timeout = timeout

        self.console = pyconsole.PythonConsole(self.verbose, self.interactive,
                                                  self.timeout)

    def post_instantiation(self):
        # TODO(albert): rewrite test validation. Inconsistent leading space is
        # currently not validated correctly (see tests).
        self.docstring = textwrap.dedent(self.docstring)
        code = []
        prompt_on = False
        leading_space = ''
        for line in self.docstring.split('\n'):
            prompt_match = self.prompt_re.match(line)
            if prompt_match:
                if prompt_on and not line.startswith(leading_space):
                    raise ex.SerializeException('Inconsistent tabs for doctest')
                elif not prompt_on:
                    prompt_on = True
                    leading_space = prompt_match.group(1)
                code.append(line.lstrip())
            elif line.endswith('...'):
                # A line consisting only of ... is treated as a noop. See
                # issue #46
                continue
            elif not line.strip():
                prompt_on = False
                leading_space = ''
            elif prompt_on:
                if not line.startswith(leading_space):
                    raise ex.SerializeException('Inconsistent tabs for doctest')
                code.append(line[len(leading_space):])
        module = self.SETUP.format(importing.path_to_module_string(self.file))
        self.case = interpreter.CodeCase(self.console, module,
                                             code='\n'.join(code))

    def run(self, env):
        """Runs the suites associated with this doctest.

        NOTE: env is intended only for use with the programmatic API to support
        Python OK tests. It is not used here.

        RETURNS:
        bool; True if the doctest completely passes, False otherwise.
        """
        output.off()
        log_id = output.new_log()

        format.print_line('-')
        print('Doctests for {}'.format(self.name))
        print()

        if not self.docstring:
            print('-- No doctests found for {} --'.format(self.name))
            success = False
        else:
            success = self.case.run()
            if success:
                print('-- OK! --')

        output.on()
        output_log = output.get_log(log_id)
        output.remove_log(log_id)

        if not success or self.verbose:
            print(''.join(output_log))

        if not success and self.interactive:
            self.console.interact()

        if success:
            return {'passed': 1, 'failed': 0, 'locked': 0}
        else:
            return {'passed': 0, 'failed': 1, 'locked': 0}

    def score(self):
        format.print_line('-')
        print('Doctests for {}'.format(self.name))
        print()
        success = self.case.run()
        score = 1.0 if success else 0.0

        print('Score: {}/1'.format(score))
        print()
        return score

    def unlock(self, interact):
        """Doctests cannot be unlocked."""

    def lock(self, hash_fn):
        """Doctests cannot be locked."""

    def dump(self):
        """Doctests do not need to be dumped, since no state changes."""
PK     ,}ÔHº;l¥  ¥  "   client/sources/common/importing.pyimport importlib
import os

def load_module(filepath):
    module_name = path_to_module_string(filepath)
    return importlib.import_module(module_name)

def path_to_module_string(filepath):
    filepath = filepath.replace('.py', '')
    module_components = []
    while filepath:
        filepath, component = os.path.split(filepath)
        module_components.insert(0, component)
    return '.'.join(module_components)
PK     ,}ÔHªì_«,  «,  $   client/sources/common/interpreter.py"""Case for generic interpreter-style tests."""

from client.sources.common import core
from client.sources.common import models
from client.utils import locking
import re
import textwrap

class CodeCase(models.Case):
    """TestCase for doctest-style Python tests."""

    code = core.String()

    def __init__(self, console, setup='', teardown='', **fields):
        """Constructor.

        PARAMETERS:
        input_str -- str; the input string, which will be dedented and
                     split along newlines.
        outputs   -- list of TestCaseAnswers
        test      -- Test or None; the test to which this test case
                     belongs.
        frame     -- dict; the environment in which the test case will
                     be executed.
        teardown  -- str; the teardown code. This code will be executed
                     regardless of errors.
        status    -- keyword arguments; statuses for the test case.
        """
        super().__init__(**fields)
        self.console = console
        self.setup = setup
        self.teardown = teardown

    def post_instantiation(self):
        self.code = textwrap.dedent(self.code)
        self.setup = textwrap.dedent(self.setup)
        self.teardown = textwrap.dedent(self.teardown)

        self.lines = self.split_code(self.code, self.console.PS1, self.console.PS2)

    def run(self):
        """Implements the GradedTestCase interface."""
        self.console.load(self.lines, setup=self.setup, teardown=self.teardown)
        return self.console.interpret()

    def lock(self, hash_fn):
        assert self.locked != False, 'called lock when self.lock = False'
        for line in self.lines:
            if isinstance(line, CodeAnswer) and not line.locked:
                line.output = [hash_fn(output) for output in line.output]
                line.locked = True
        self.locked = True
        self._sync_code()

    def unlock(self, unique_id_prefix, case_id, interact):
        """Unlocks the CodeCase.

        PARAMETERS:
        unique_id_prefix -- string; a prefix of a unique identifier for this
                            Case, for purposes of analytics.
        case_id          -- string; an identifier for this Case, for purposes of
                            analytics.
        interact         -- function; handles user interaction during the unlocking
                            phase.
        """
        print(self.setup.strip())
        prompt_num = 0
        current_prompt = []
        try:
            for line in self.lines:
                if isinstance(line, str) and line:
                    print(line)
                    current_prompt.append(line)
                elif isinstance(line, CodeAnswer):
                    prompt_num += 1
                    if not line.locked:
                        print('\n'.join(line.output))
                        continue

                    unique_id = self._construct_unique_id(unique_id_prefix, self.lines)
                    line.output = interact(unique_id,
                                           case_id + ' >  Prompt {}'.format(prompt_num),
                                           '\n'.join(current_prompt),
                                           line.output, line.choices)
                    line.locked = False
                    current_prompt = []
            self.locked = False
        finally:
            self._sync_code()

    @classmethod
    def split_code(cls, code, PS1, PS2):
        """Splits the given string of code based on the provided PS1 and PS2
        symbols.

        PARAMETERS:
        code -- str; lines of interpretable code, using PS1 and PS2 prompts
        PS1  -- str; first-level prompt symbol
        PS2  -- str; second-level prompt symbol

        RETURN:
        list; a processed sequence of lines corresponding to the input code.
        """
        processed_lines = []
        for line in textwrap.dedent(code).split('\n'):
            if not line or line.startswith(PS1) or line.startswith(PS2):
                processed_lines.append(line)
                continue

            assert len(processed_lines) > 0, 'code improperly formated: {}'.format(code)
            if not isinstance(processed_lines[-1], CodeAnswer):
                processed_lines.append(CodeAnswer())
            processed_lines[-1].update(line)
        return processed_lines

    def _sync_code(self):
        """Syncs the current state of self.lines with self.code, the
        serializable string representing the set of code.
        """
        new_code = []
        for line in self.lines:
            if isinstance(line, CodeAnswer):
                new_code.append(line.dump())
            else:
                new_code.append(line)
        self.code = '\n'.join(new_code)

    def _construct_unique_id(self, id_prefix, lines):
        """Constructs a unique ID for a particular prompt in this case,
        based on the id_prefix and the lines in the prompt.
        """
        text = []
        for line in lines:
            if isinstance(line, str):
                text.append(line)
            elif isinstance(line, CodeAnswer):
                text.append(line.dump())
        return id_prefix + '\n' + '\n'.join(text)


class Console(object):
    PS1 = '> '
    PS2 = '. '

    _output_fn = repr

    ####################
    # Public interface #
    ####################

    def __init__(self, verbose, interactive, timeout=None):
        self.verbose = verbose
        self.interactive = interactive
        self.timeout = timeout
        self.skip_locked_cases = True
        self.load('')   # Initialize empty code.

    def load(self, code, setup='', teardown=''):
        """Prepares a set of setup, test, and teardown code to be
        run in the console.

        PARAMETERS:
        code     -- list; processed lines of code. Elements in the list are
                    either strings (input) or CodeAnswer objects (output)
        setup    -- str; raw setup code
        teardown -- str; raw teardown code
        """
        self._setup = textwrap.dedent(setup).split('\n')
        self._code = code
        self._teardown = textwrap.dedent(teardown).split('\n')

    def interpret(self):
        """Interprets the console on the loaded code.

        RETURNS:
        bool; True if the code passes, False otherwise.
        """
        if not self._interpret_lines(self._setup):
            return False

        success = self._interpret_lines(self._code, compare_all=True)
        success &= self._interpret_lines(self._teardown)
        return success

    def interact(self):
        """Opens up an interactive session with the current state of
        the console.
        """
        pass

    def evaluate(self, code):
        """Evaluates the given code.

        PARAMETERS:
        code -- str

        RETURNS:
        (result, output), where
        result -- the evaluated result of the code
        output -- str; any output that was printed to stdout
        """
        raise NotImplementedError

    ############################
    # Interpretation utilities #
    ############################

    def _interpret_lines(self, lines, compare_all=False):
        """Interprets the set of lines.

        PARAMTERS:
        lines       -- list of str; lines of code
        compare_all -- bool; if True, check for no output for lines that are not
                       followed by a CodeAnswer

        RETURNS:
        bool; True if successful, False otherwise.
        """
        current = []
        for line in lines + ['']:
            if isinstance(line, str):
                if current and (line.startswith(self.PS1) or not line):
                    # Previous prompt ends when PS1 or a blank line occurs
                    try:
                        if compare_all:
                            self._compare('', '\n'.join(current))
                        else:
                            self.evaluate('\n'.join(current))
                    except ConsoleException:
                        return False
                    current = []
                if line:
                    print(line)
                line = self._strip_prompt(line)
                current.append(line)
            elif isinstance(line, CodeAnswer):
                assert len(current) > 0, 'Answer without a prompt'
                try:
                    self._compare('\n'.join(line.output), '\n'.join(current))
                except ConsoleException:
                    return False
                current = []
        return True

    def _compare(self, expected, code):
        try:
            value, printed = self.evaluate(code)
        except ConsoleException as e:
            actual = e.exception_type
        else:
            if value is not None:
                print(self._output_fn(value))
                actual = (printed + self._output_fn(value)).strip()
            else:
                actual = printed.strip()

        expected = expected.strip()
        
        if not self.skip_locked_cases and expected != actual:
            actual = locking.lock(self.hash_key, actual)
            if expected != actual:
                print()
                print("# Error: expected and actual results do not match")
                raise ConsoleException
        elif expected != actual:
            print()
            print('# Error: expected')
            print('\n'.join('#     {}'.format(line)
                            for line in expected.split('\n')))
            print('# but got')
            print('\n'.join('#     {}'.format(line)
                            for line in actual.split('\n')))
            raise ConsoleException

    def _strip_prompt(self, line):
        if line.startswith(self.PS1):
            return line[len(self.PS1):]
        elif line.startswith(self.PS2):
            return line[len(self.PS2):]
        return line


class CodeAnswer(object):
    status_re = re.compile(r'^#\s*(.+?):\s*(.*)\s*$')
    locked_re = re.compile(r'^#\s*locked\s*$')

    def __init__(self, output=None, choices=None, explanation='', locked=False):
        self.output = output or []
        self.choices = choices or []
        self.locked = locked
        self.explanation = explanation

    def dump(self):
        result = list(self.output)
        if self.locked:
            result.append('# locked')
            if self.choices:
                for choice in self.choices:
                    result.append('# choice: ' + choice)
        if self.explanation:
            result.append('# explanation: ' + self.explanation)
        return '\n'.join(result)

    def update(self, line):
        if self.locked_re.match(line):
            self.locked = True
            return
        match = self.status_re.match(line)
        if not match:
            self.output.append(line)
        elif match.group(1) == 'locked':
            self.locked = True
        elif match.group(1) == 'explanation':
            self.explanation = match.group(2)
        elif match.group(1) == 'choice':
            self.choices.append(match.group(2))


class ConsoleException(Exception):
    def __init__(self, exception=None, exception_type=''):
        self.exception = exception
        if not exception or exception_type:
            self.exception_type = exception_type
        else:
            self.exception_type = exception.__class__.__name__

PK     ,}ÔHœ-2˜¿  ¿     client/sources/common/core.pyfrom client import exceptions as ex
import collections

###############
# Field types #
###############

class NoValue(object):
    pass

NoValue = NoValue()

class Field(object):
    _default = NoValue

    def __init__(self, optional=False, **kargs):
        self._optional = optional
        if 'default' in kargs:
            value = kargs['default']
            if not self.is_valid(value):
                raise ex.SerializeException('Invalid default: {}'.format(value))
            self._optional = True
            self._default = value

    @property
    def optional(self):
        return self._optional

    @property
    def default(self):
        return self._default

    def is_valid(self, value):
        """Subclasses should override this method for field validation."""
        return True

    def coerce(self, value):
        """Subclasses should override this method for type coercion.

        Default version will simply return the argument. If the argument
        is not valid, a SerializeException is raised.

        For primitives like booleans, ints, floats, and strings, use
        this default version to avoid unintended type conversions."""
        if not self.is_valid(value):
            raise ex.SerializeException('{} is not a valid value for '
                                        'type {}'.format(value, self.__class__.__name__))
        return value

    def to_json(self, value):
        """Subclasses should override this method for JSON encoding."""
        if not self.is_valid(value):
            raise ex.SerializeException('Invalid value: {}'.format(value))
        return value

class Boolean(Field):
    def is_valid(self, value):
        return value in (True, False)

class Int(Field):
    def is_valid(self, value):
        return type(value) == int

class Float(Field):
    def is_valid(self, value):
        return type(value) in (int, float)

class String(Field):
    def is_valid(self, value):
        return type(value) == str

class List(Field):
    def __init__(self, type=None, **kargs):
        """Constructor for a List field.

        PARAMETERS:
        type -- type; if type is None, the List can be heterogeneous.
                Otherwise, the List must be homogeneous with elements
                of the specified type.
        """
        super().__init__(**kargs)
        self._type = type

    def is_valid(self, value):
        valid = type(value) == list
        if self._type is not None:
            valid &= all(isinstance(e, self._type) for e in value)
        return valid

    def coerce(self, value):
        if self._type is None:
            try:
                return list(value)
            except TypeError as e:
                raise ex.SerializeException(str(e))
        else:
            # TODO(albert): find a way to do better element-wise type coercion
            # so that constructors can take additional arguments
            try:
                return [self._type(elem) for elem in value]
            except TypeError as e:
                raise ex.SerializeException(str(e))

    def to_json(self, value):
        value = super().to_json(value)
        return [elem.to_json() if hasattr(elem, 'to_json') else elem
                             for elem in value]

class Dict(Field):
    def __init__(self, keys=None, values=None, ordered=False, **kargs):
        super().__init__(**kargs)
        self._keys = keys
        self._values = values
        self._constructor = collections.OrderedDict if ordered else dict
        self._ordered = ordered

    @property
    def ordered(self):
        return self._ordered

    def is_valid(self, value):
        valid = isinstance(value, dict)
        if self._keys is not None:
            valid &= all(isinstance(k, self._keys) for k in value)
        if self._values is not None:
            valid &= all(isinstance(v, self._values) for v in value.values())
        return valid

    def coerce(self, value):
        try:
            coerced = self._constructor(value)
        except TypeError as e:
            raise ex.SerializeException(str(e))

        result = self._constructor()
        for k, v in coerced.items():
            if self._keys is not None:
                k = self._keys(k)
            elif self._values is not None:
                v = self._values(k)
            result[k] = v
        return result

    def to_json(self, value):
        value = super().to_json(value)
        result = self._constructor()
        for k, v in value.items():
            if hasattr(k, 'to_json'):
                k = k.to_json()
            if hasattr(v, 'to_json'):
                v = v.to_json()
            result[k] = v
        return result

########################
# Serializable Objects #
########################

class _SerializeMeta(type):
    def __init__(cls, name, bases, attrs):
        type.__init__(cls, name, bases, attrs)
        cls._fields = {}
        for base in bases:
            if hasattr(base, '_fields'):
                cls._fields.update(base._fields)
        cls._fields.update({attr: value for attr, value in attrs.items()
                                        if isinstance(value, Field)})

    def __call__(cls, *args, **kargs):
        obj = type.__call__(cls, *args, **kargs)
        # Validate existing arguments
        for attr, value in kargs.items():
            if attr not in cls._fields:
                raise ex.SerializeException('__init__() got an unexpected '
                                'keyword argument: {}'.format(attr))
            else:
                setattr(obj, attr, value)
        # Check for missing/default fields
        for attr, value in cls._fields.items():
            if attr in kargs:
                continue
            elif value.optional:
                setattr(obj, attr, value.default)
            else:
                raise ex.SerializeException('__init__() missing expected '
                                'argument {}'.format(attr))
        obj.post_instantiation()
        return obj

class Serializable(metaclass=_SerializeMeta):
    def __init__(self, *args, **kargs):
        pass

    def __setattr__(self, attr, value):
        cls = type(self)
        if attr in cls._fields:
            field = cls._fields[attr]
            if value != NoValue and not field.is_valid(value):
                value = field.coerce(value)
        super().__setattr__(attr, value)

    def post_instantiation(self):
        """Subclasses can override this method to perform post-instantiation
        work.
        """
        pass

    def to_json(self):
        cls = type(self)
        json = {}
        for attr, field in cls._fields.items():
            value = getattr(self, attr)
            if not field.optional or value != NoValue:
                json[attr] = field.to_json(value)
        return json

PK     ,}ÔH            !   client/sources/common/__init__.pyPK     ,}ÔHÅ)ï`€
  €
  "   client/sources/common/pyconsole.py"""Case for doctest-style Python tests."""

from client import exceptions
from client.sources.common import interpreter
from client.utils import output
from client.utils import timer
import code
import textwrap
import traceback

class PythonConsole(interpreter.Console):
    PS1 = '>>> '
    PS2 = '... '

    def __init__(self, verbose, interactive, timeout=None):
        self._original_frame = {}
        super().__init__(verbose, interactive, timeout)

    def load(self, code, setup='', teardown=''):
        """Prepares a set of setup, test, and teardown code to be
        run in the console.

        PARAMETERS:
        code     -- list; processed lines of code. Elements in the list are
                    either strings (input) or CodeAnswer objects (output)
        setup    -- str; raw setup code
        teardown -- str; raw teardown code
        """
        super().load(code, setup, teardown)
        self._frame = self._original_frame.copy()

    def load_env(self, env):
        self._original_frame = env

    def interact(self):
        """Opens up an interactive session with the current state of
        the console.
        """
        console = code.InteractiveConsole(self._frame)
        console.interact('# Interactive console. Type exit() to quit')

    def evaluate(self, code):
        log_id = output.new_log()
        try:
            try:
                result = timer.timed(self.timeout, eval, (code, self._frame))
            except SyntaxError:
                timer.timed(self.timeout, exec, (code, self._frame))
                result = None
        except RuntimeError as e:
            stacktrace_length = 15
            stacktrace = traceback.format_exc().strip().split('\n')
            print('Traceback (most recent call last):\n  ...')
            print('\n'.join(stacktrace[-stacktrace_length:]))
            raise interpreter.ConsoleException(e)
        except exceptions.Timeout as e:
            print('# Error: evaluation exceeded {} seconds.'.format(e.timeout))
            raise interpreter.ConsoleException(e)
        except Exception as e:
            stacktrace = traceback.format_exc()
            token = '<string>'
            token_start = stacktrace.rfind(token)
            index = stacktrace.find('\n', token_start) + 1
            stacktrace = stacktrace[index:].rstrip('\n')
            if '\n' in stacktrace:
                print('Traceback (most recent call last):')
            print(stacktrace)
            raise interpreter.ConsoleException(e)
        else:
            printed_output = ''.join(output.get_log(log_id))
            return result, printed_output
        finally:
            output.remove_log(log_id)

PK     ,}ÔHúÙ«0	  0	     client/sources/common/models.py"""Models for serialization of tests."""

from client.sources.common import core

class Test(core.Serializable):
    name = core.String()
    points = core.Float()
    partner = core.String(optional=True)

    def run(self, env):
        """Subclasses should override this method to run tests.

        NOTE: env is intended only for use with the programmatic API for
        Python OK tests.
        """
        raise NotImplementedError

    def score(self):
        """Subclasses should override this method to score the test."""
        raise NotImplementedError

    def unlock(self, interact):
        """Subclasses should override this method to lock the test."""
        raise NotImplementedError

    def lock(self, hash_fn):
        """Subclasses should override this method to lock the test."""
        raise NotImplementedError

    def dump(self):
        """Subclasses should override this method for serialization."""
        raise NotImplementedError

class Case(core.Serializable):
    """Abstract case class."""

    hidden = core.Boolean(default=False)
    locked = core.Boolean(optional=True)

    def run(self):
        """Subclasses should override this method for running a test case.

        RETURNS:
        bool; True if the test case passes, False otherwise.
        """
        raise NotImplementedError

    def lock(self, hash_fn):
        """Subclasses should override this method for locking a test case.

        This method should mutate the object into a locked state.

        PARAMETERS:
        hash_fn -- function; computes the hash code of a given string.
        """
        raise NotImplementedError

    def unlock(self, unique_id_prefix, case_id, interact):
        """Subclasses should override this method for unlocking a test case.

        It is the responsibility of the the subclass to make any changes to the
        test case, including setting its locked field to False.

        PARAMETERS:
        unique_id_prefix -- string; an identifier for this Case, for purposes of
                            analytics.
        case_id          -- string; an identifier for this Case, for purposes of
                            analytics.
        interact         -- function; handles user interaction during the unlocking
                            phase.
        """
        raise NotImplementedError

PK     egÖHŸ°´Ó§	  §	     client/sources/ok_test/wwpp.py"""Case for What-would-Python-print tests."""

from client import exceptions as ex
from client.sources.common import core
from client.sources.common import interpreter
from client.sources.common import pyconsole
from client.sources.ok_test import models
import logging

log = logging.getLogger(__name__)

class WwppSuite(models.Suite):
    scored = core.Boolean(default=False)

    console_type = pyconsole.PythonConsole

    def __init__(self, verbose, interactive, timeout=None, **fields):
        super().__init__(verbose, interactive, timeout, **fields)
        self.console = self.console_type(verbose, interactive, timeout)

    def post_instantiation(self):
        for i, case in enumerate(self.cases):
            if not isinstance(case, dict):
                raise ex.SerializeException('Test cases must be dictionaries')
            self.cases[i] = WwppCase(self.console, **case)

    def run(self, test_name, suite_number):
        results = {
            'passed': 0,
            'failed': 0,
            'locked': 0,
        }
        for i, case in enumerate(self.cases):
            if case.locked == True or results['locked'] > 0:
                # If a test case is locked, refuse to run any of the subsequent
                # test cases
                log.info('Case {} is locked'.format(i))
                results['locked'] += 1
                continue

            success, output_log = self._run_case(test_name, suite_number,
                                                 case, i + 1)
            assert success, 'Wwpp case should never fail while grading'
            results['passed'] += 1

            if self.verbose:
                print(''.join(output_log))
        return results

class WwppCase(interpreter.CodeCase):

    def run(self):
        """Runs the What-would-Python-print test case.

        RETURNS:
        bool; True if the test case passes, False otherwise.
        """
        for line in self.lines:
            if isinstance(line, str) and line:
                print(line)
            elif isinstance(line, interpreter.CodeAnswer):
                assert not line.locked, 'WwppCase should be unlocked in run'
                print('\n'.join(line.output))
        return True

    def unlock(self, unique_id_prefix, case_id, interact):
        print('What would Python display? If you get stuck, try it out in the '
              'Python\ninterpreter!')
        super().unlock(unique_id_prefix, case_id, interact)

PK     ,}ÔHp!býÙ  Ù      client/sources/ok_test/scheme.py"""Console for interpreting Scheme. In particular, this is meant to integrate
with UC Berkeley CS 61A's Scheme project. SchemeConsole expects the an
importable module called "scheme" with the following interface:

    scheme.create_global_frame()
    scheme.read_eval_print_loop(next_line_fn, frame, interactive)
    scheme.buffer_input()
    scheme.read_line(code)
    scheme.scheme_eval(exp, env)
"""

from client import exceptions
from client.sources.common import interpreter
from client.sources.ok_test import doctest
from client.utils import output
from client.utils import timer
import importlib
import sys
import textwrap
import traceback

class SchemeConsole(interpreter.Console):
    PS1 = 'scm> '
    PS2 = '.... '

    MODULE = 'scheme'
    _output_fn = str

    def load(self, code, setup='', teardown=''):
        """Prepares a set of setup, test, and teardown code to be
        run in the console.

        Loads the Scheme module before loading any code.
        """
        self._import_scheme()
        super().load(code, setup, teardown)
        self._frame = self.scheme.create_global_frame()

    def interact(self):
        """Opens up an interactive session with the current state of
        the console.
        """
        self.scheme.read_eval_print_loop(self.scheme.buffer_input, self._frame,
                                         True)

    def evaluate(self, code):
        if not code.strip():
            # scheme.scheme_read can't handle empty strings.
            return None, ''
        log_id = output.new_log()
        try:
            exp = self.scheme.read_line(code)
            result = timer.timed(self.timeout, self.scheme.scheme_eval,
                                 (exp, self._frame))
        except RuntimeError as e:
            stacktrace_length = 15
            stacktrace = traceback.format_exc().strip().split('\n')
            print('Traceback (most recent call last):\n  ...')
            print('\n'.join(stacktrace[-stacktrace_length:]))
            raise interpreter.ConsoleException(e)
        except exceptions.Timeout as e:
            print('# Error: evaluation exceeded {} seconds.'.format(e.timeout))
            raise interpreter.ConsoleException(e)
        except self.scheme.SchemeError as e:
            print('# Error: {}'.format(e))
            raise interpreter.ConsoleException(e, exception_type='SchemeError')
        except Exception as e:
            stacktrace = traceback.format_exc()
            token = '<module>\n'
            index = stacktrace.rfind(token) + len(token)
            stacktrace = stacktrace[index:].rstrip('\n')
            if '\n' in stacktrace:
                print('Traceback (most recent call last):')
            print(stacktrace)
            raise interpreter.ConsoleException(e)
        else:
            printed_output = ''.join(output.get_log(log_id))
            return result, printed_output
        finally:
            output.remove_log(log_id)

    def _import_scheme(self):
        try:
            sys.path.insert(0, 'scheme')
            self.scheme = importlib.import_module(self.MODULE)
        except ImportError as e:
            raise exceptions.ProtocolException('Could not import scheme')

class SchemeSuite(doctest.DoctestSuite):
    console_type = SchemeConsole

PK     ,}ÔHô¿™ë”  ”      client/sources/ok_test/sqlite.py"""Console for interpreting sqlite."""

from client import exceptions
from client.sources.common import core, interpreter
from client.sources.ok_test import doctest
from client.utils import format
from client.utils import timer
import importlib
import os
import re
import subprocess

class SqliteConsole(interpreter.Console):
    PS1 = 'sqlite> '
    PS2 = '   ...> '

    VERSION = (3, 8, 3)

    ordered = False # will be set by SqliteSuite.__init__

    def load(self, code, setup='', teardown=''):
        """Prepares a set of setup, test, and teardown code to be
        run in the console.
        """
        super().load(code, setup, teardown)

    def interpret(self):
        """Interprets the code in this Console.

        If there is an executable called "sqlite3" (in the current directory is
        okay), pipe the test case into sqlite3. Otherwise, report an error.
        """
        env = dict(os.environ,
                   PATH=os.getcwd() + os.pathsep + os.environ['PATH'])
        if self._has_sqlite_cli(env):
            try:
                test, expected, actual = self._use_sqlite_cli(env)
            except interpreter.ConsoleException:
                return False
            print(format.indent(test, 'sqlite> '))  # TODO: show test with prompt
            print(actual)
            try:
                self._diff_output(expected, actual)
                return True
            except interpreter.ConsoleException:
                return False
        else:
            print('ERROR: could not run sqlite3.')
            print('Tests will not pass, but you can still submit your assignment.')
            print('Please download the newest version of sqlite3 into this folder')
            print('to run tests.')
            return False

    def interact(self):
        """Opens up an interactive session with the current state of
        the console.
        """
        # TODO(albert)

    def _diff_output(self, expected, actual):
        """Raises an interpreter.ConsoleException if expected and actual output
        don't match.

        PARAMETERS:
        expected -- str; may be multiple lines
        actual   -- str; may be multiple lines
        """
        expected = expected.split('\n')
        actual = actual.split('\n')

        if self.ordered:
            correct = expected == actual
        else:
            correct = sorted(expected) == sorted(actual)

        if not correct:
            print()
            error_msg = '# Error: expected'
            if self.ordered:
                error_msg += ' ordered output'
            print(error_msg)
            print('\n'.join('#     {}'.format(line)
                            for line in expected))
            print('# but got')
            print('\n'.join('#     {}'.format(line)
                            for line in actual))
            raise interpreter.ConsoleException

    def _has_sqlite_cli(self, env):
        """Checks if the command "sqlite3" is executable with the given
        shell environment variables.

        PARAMETERS:
        env -- mapping; represents shell environment variables. Primarily, this
               allows modifications to PATH to check the current directory first.

        RETURNS:
        bool; True if "sqlite3" is executable and the version is at least
        self.VERSION; False otherwise.
        """
        # Modify PATH in subprocess to check current directory first for sqlite3
        # executable.
        try:
            version = subprocess.check_output(['sqlite3', '--version'],
                                              env=env).decode()
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False
        version = version.split(' ')[0].split('.')
        version_info = tuple(int(num) for num in version)
        return version_info >= self.VERSION

    def _use_sqlite_cli(self, env):
        """Pipes the test case into the "sqlite3" executable.

        The method _has_sqlite_cli MUST be called before this method is called.

        PARAMETERS:
        env -- mapping; represents shell environment variables. Primarily, this
               allows modifications to PATH to check the current directory first.

        RETURNS:
        (test, expected, result), where
        test     -- str; test input that is piped into sqlite3
        expected -- str; the expected output, for display purposes
        result   -- str; the actual output from piping input into sqlite3
        """
        test = []
        expected = []
        for line in self._setup + self._code + self._teardown:
            if isinstance(line, interpreter.CodeAnswer):
                expected.extend(line.output)
            elif line.startswith(self.PS1):
                test.append(line[len(self.PS1):])
            elif line.startswith(self.PS2):
                test.append(line[len(self.PS2):])
        test = '\n'.join(test)
        process = subprocess.Popen(['sqlite3'],
                                    universal_newlines=True,
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE,
                                    env=env)
        try:
            result, error = process.communicate(test, timeout=self.timeout)
        except subprocess.TimeoutExpired as e:
            process.kill()
            print('# Error: evaluation exceeded {} seconds.'.format(self.timeout))
            raise interpreter.ConsoleException(exceptions.Timeout(self.timeout))
        return test, '\n'.join(expected), (error + '\n' + result).strip()

class SqliteSuite(doctest.DoctestSuite):
    console_type = SqliteConsole
    # TODO: Ordered should be a property of cases, not entire suites.
    ordered = core.Boolean(default=False)

    def __init__(self, verbose, interactive, timeout=None, **fields):
        super().__init__(verbose, interactive, timeout, **fields)
        self.console.ordered = fields.get('ordered', False)
PK     ,}ÔH¾BA7  7  !   client/sources/ok_test/doctest.pyfrom client import exceptions as ex
from client.sources.common import core
from client.sources.common import interpreter
from client.sources.common import pyconsole
from client.sources.ok_test import models
from client.utils import format
import logging

log = logging.getLogger(__name__)

class DoctestSuite(models.Suite):
    setup = core.String(default='')
    teardown = core.String(default='')

    console_type = pyconsole.PythonConsole

    # A hack that allows OkTest to identify DoctestSuites without circular
    # imports.
    doctest_suite_flag = True

    def __init__(self, verbose, interactive, timeout=None, **fields):
        super().__init__(verbose, interactive, timeout, **fields)
        self.skip_locked_cases = True
        self.console = self.console_type(verbose, interactive, timeout)

    def post_instantiation(self):
        for i, case in enumerate(self.cases):
            if not isinstance(case, dict):
                raise ex.SerializeException('Test cases must be dictionaries')
            self.cases[i] = interpreter.CodeCase(self.console, self.setup,
                                                 self.teardown, **case)

    def run(self, test_name, suite_number, env=None):
        """Runs test for the doctest suite.

        PARAMETERS:
        test_name    -- str; the name of the parent test. Used for printing
                     purposes.
        suite_number -- int; the suite number in relation to the parent test.
                     Used for printing purposes.
        env          -- dict; environment in which to run tests. If None, an
                     empty dictionary is used instead.

        RETURNS:
        dict; results of the following form:
        {
            'passed': int,
            'failed': int,
            'locked': int,
        }
        """
        results = {
            'passed': 0,
            'failed': 0,
            'locked': 0,
        }

        if env is not None:
            # env should be None in the command-line scenario. env should only
            # be non-None in the programmatic API case.
            self.console.load_env(env)

        for i, case in enumerate(self.cases):
            log.info('Running case {}'.format(i))

            if (case.locked == True or results['locked'] > 0) and self.skip_locked_cases:
                # If a test case is locked, refuse to run any of the subsequent
                # test cases
                log.info('Case {} is locked'.format(i))
                results['locked'] += 1
                continue

            success, output_log = self._run_case(test_name, suite_number,
                                                 case, i + 1)

            if not success or self.verbose:
                print(''.join(output_log))

            if not success and self.interactive:
                self.console.interact()

            if success:
                results['passed'] += 1
            else:
                results['failed'] += 1

            if not success and not self.verbose:
                # Stop at the first failed test
                break
        return results
PK     èIl†óÔ  Ô  "   client/sources/ok_test/__init__.pyfrom client import exceptions as ex
from client.sources.common import importing
from client.sources.ok_test import concept
from client.sources.ok_test import doctest
from client.sources.ok_test import models
from client.sources.ok_test import logic
from client.sources.ok_test import scheme
from client.sources.ok_test import sqlite
from client.sources.ok_test import wwpp
import copy
import logging
import os

log = logging.getLogger(__name__)

SUITES = {
    'doctest': doctest.DoctestSuite,
    'concept': concept.ConceptSuite,
    'logic': logic.LogicSuite,
    'scheme': scheme.SchemeSuite,
    'sqlite': sqlite.SqliteSuite,
    'wwpp': wwpp.WwppSuite,
}

def load(file, parameter, assign):
    """Loads an OK-style test from a specified filepath.

    PARAMETERS:
    file -- str; a filepath to a Python module containing OK-style
            tests.

    RETURNS:
    Test
    """
    filename, ext = os.path.splitext(file)
    if not os.path.isfile(file) or ext != '.py':
        log.info('Cannot import {} as an OK test'.format(file))
        raise ex.LoadingException('Cannot import {} as an OK test'.format(file))

    try:
        test = importing.load_module(file).test
        test = copy.deepcopy(test)
    except Exception as e:
        raise ex.LoadingException('Error importing file {}: {}'.format(file, str(e)))

    name = os.path.basename(filename)
    try:
        return {name: models.OkTest(file, SUITES, assign.endpoint,
                                    assign.cmd_args.verbose,
                                    assign.cmd_args.interactive,
                                    assign.cmd_args.timeout, **test)}
    except ex.SerializeException:
        raise ex.LoadingException('Cannot load OK test {}'.format(file))
PK     ,}ÔHg–ñs5  5      client/sources/ok_test/models.pyfrom client import exceptions as ex
from client.sources.common import core
from client.sources.common import models
from client.utils import format
from client.utils import output
import os

##########
# Models #
##########


class OkTest(models.Test):
    suites = core.List()
    description = core.String(optional=True)

    def __init__(self, file, suite_map, assign_name, verbose, interactive,
                 timeout=None, **fields):
        super().__init__(**fields)
        self.file = file
        self.suite_map = suite_map
        self.verbose = verbose
        self.interactive = interactive
        self.timeout = timeout
        self.assignment_name = assign_name

    def post_instantiation(self):
        for i, suite in enumerate(self.suites):
            if not isinstance(suite, dict):
                raise ex.SerializeException('Test cases must be dictionaries')
            elif 'type' not in suite:
                raise ex.SerializeException('Suites must have field "type"')
            elif suite['type'] not in self.suite_map:
                raise ex.SerializeException('Invalid suite type: '
                                            '{}'.format(suite['type']))
            self.suites[i] = self.suite_map[suite['type']](
                    self.verbose, self.interactive, self.timeout, **suite)

    def run(self, env):
        """Runs the suites associated with this OK test.

        NOTE: env is intended only for use with the programmatic API to support
        Python OK tests. For that reason, it is only passed to DoctestSuites.

        RETURNS:
        dict; the results for this test, in the form
        {
            'passed': int,
            'failed': int,
            'locked': int,
        }
        """
        passed, failed, locked = 0, 0, 0
        for i, suite in enumerate(self.suites):
            if hasattr(suite, 'doctest_suite_flag'):
                # A hack that allows programmatic API users to plumb a custom
                # environment through to Python tests.
                results = suite.run(self.name, i + 1, env)
            else:
                results = suite.run(self.name, i + 1)

            passed += results['passed']
            failed += results['failed']
            locked += results['locked']

            if not self.verbose and (failed > 0 or locked > 0):
                # Stop at the first failed test
                break

        if locked > 0:
            print()
            print('There are still locked tests! '
                  'Use the -u option to unlock them')

        if type(self.description) == str and self.description:
            print()
            print(self.description)
            print()
        return {
            'passed': passed,
            'failed': failed,
            'locked': locked,
        }

    def score(self):
        """Runs test cases and computes the score for this particular test.

        Scores are determined by aggregating results from suite.run() for each
        suite. A suite is considered passed only if it results in no locked
        nor failed results.

        The points available for this test are distributed evenly across
        scoreable (i.e. unlocked and 'scored' = True) suites.
        """
        passed, total = 0, 0
        for i, suite in enumerate(self.suites):
            if not suite.scored:
                continue

            total += 1
            results = suite.run(self.name, i + 1)

            if results['locked'] == 0 and results['failed'] == 0:
                passed += 1
        if total > 0:
            score = passed * self.points / total
        else:
            score = 0.0

        format.print_progress_bar(self.name, passed, total - passed, 0)
        print()
        return score

    def unlock(self, interact):
        total_cases = len([case for suite in self.suites
                           for case in suite.cases])
        for suite_num, suite in enumerate(self.suites):
            for case_num, case in enumerate(suite.cases):
                case_id = '{} > Suite {} > Case {}'.format(
                            self.name, suite_num + 1, case_num + 1)

                format.print_line('-')
                print(case_id)
                print('(cases remaining: {})'.format(total_cases))
                print()
                total_cases -= 1

                if case.locked is not True:
                    print('-- Already unlocked --')
                    print()
                    continue

                case.unlock(self.unique_id_prefix, case_id, interact)

        assert total_cases == 0, 'Number of cases is incorrect'
        format.print_line('-')
        print('OK! All cases for {} unlocked.'.format(self.name))
        print()

    def lock(self, hash_fn):
        format.print_line('-')
        print(self.name)

        for suite_num, suite in enumerate(list(self.suites)):
            for case_num, case in enumerate(list(suite.cases)):
                message = '* Suite {} > Case {}: '.format(suite_num, case_num)
                if case.hidden:
                    suite.cases.remove(case)
                    print(message + 'removing hidden case')
                elif case.locked == core.NoValue:
                    case.lock(hash_fn)
                    print(message + 'locking')
                elif case.locked is False:
                    print(message + 'leaving unlocked')
                elif case.locked is True:
                    print(message + 'already unlocked')
            if not suite.cases:
                self.suites.remove(suite)
                print('* Suite {}: removing empty suite'.format(suite_num))
        print()

    def dump(self):
        # TODO(albert): add log messages
        # TODO(albert): writing causes an error halfway, the tests
        # directory may be left in a corrupted state.
        # TODO(albert): might need to delete obsolete test files too.
        json = format.prettyjson(self.to_json())
        test_tmp = "{}.tmp".format(self.file)

        with open(test_tmp, 'w', encoding='utf-8') as f:
            f.write('test = {}\n'.format(json))

        # Use an atomic rename operation to prevent test corruption
        os.replace(test_tmp, self.file)

    @property
    def unique_id_prefix(self):
        return self.assignment_name + '\n' + self.name


class Suite(core.Serializable):
    type = core.String()
    scored = core.Boolean(default=True)
    cases = core.List()

    def __init__(self, verbose, interactive, timeout=None, **fields):
        super().__init__(**fields)
        self.verbose = verbose
        self.interactive = interactive
        self.timeout = timeout

    def run(self, test_name, suite_number):
        """Subclasses should override this method to run tests.

        PARAMETERS:
        test_name    -- str; name of the parent test.
        suite_number -- int; suite number, assumed to be 1-indexed.

        RETURNS:
        dict; results of the following form:
        {
            'passed': int,
            'failed': int,
            'locked': int,
        }
        """
        raise NotImplementedError

    def _run_case(self, test_name, suite_number, case, case_number):
        """A wrapper for case.run().

        Prints informative output and also captures output of the test case
        and returns it as a log. The output is suppressed -- it is up to the
        calling function to decide whether or not to print the log.
        """
        output.off()    # Delay printing until case status is determined.
        log_id = output.new_log()

        format.print_line('-')
        print('{} > Suite {} > Case {}'.format(test_name, suite_number,
                                               case_number))
        print()

        success = case.run()
        if success:
            print('-- OK! --')

        output.on()
        output_log = output.get_log(log_id)
        output.remove_log(log_id)

        return success, output_log
PK     ,}ÔH!Bž‡e  e  !   client/sources/ok_test/concept.py"""Case for conceptual tests.

ConceptCases are designed to be natural language tests that help
students understand high-level understanding. As such, these test cases
focus mainly on unlocking.
"""

from client import exceptions as ex
from client.sources.common import models as common_models
from client.sources.ok_test import models as ok_models
from client.sources.common import core
import textwrap
import logging

log = logging.getLogger(__name__)

class ConceptSuite(ok_models.Suite):
    scored = core.Boolean(default=False)

    def post_instantiation(self):
        for i, case in enumerate(self.cases):
            if not isinstance(case, dict):
                raise ex.SerializeException('Test cases must be dictionaries')
            self.cases[i] = ConceptCase(**case)

    def run(self, test_name, suite_number):
        results = {
            'passed': 0,
            'failed': 0,
            'locked': 0,
        }
        for i, case in enumerate(self.cases):
            if case.locked == True or results['locked'] > 0:
                # If a test case is locked, refuse to run any of the subsequent
                # test cases
                log.info('Case {} is locked'.format(i))
                results['locked'] += 1
                continue

            success, output_log = self._run_case(test_name, suite_number,
                                                 case, i + 1)
            assert success, 'Concept case should never fail while grading'
            results['passed'] += 1

            if self.verbose:
                print(''.join(output_log))
        return results

class ConceptCase(common_models.Case):
    question = core.String()
    answer = core.String()
    choices = core.List(type=str, optional=True)

    def post_instantiation(self):
        self.question = textwrap.dedent(self.question).strip()
        self.answer = textwrap.dedent(self.answer).strip()

        if self.choices != core.NoValue:
            for i, choice in enumerate(self.choices):
                self.choices[i] = textwrap.dedent(choice).strip()

    def run(self):
        """Runs the conceptual test case.

        RETURNS:
        bool; True if the test case passes, False otherwise.
        """
        print('Q: ' + self.question)
        print('A: ' + self.answer)
        return True

    def lock(self, hash_fn):
        self.answer = hash_fn(self.answer)
        self.locked = True

    def unlock(self, unique_id_prefix, case_id, interact):
        """Unlocks the conceptual test case."""
        print('Q: ' + self.question)
        answer = interact(unique_id_prefix + '\n' + self.question,
                          case_id, self.question, [self.answer], self.choices)
        assert len(answer) == 1
        answer = answer[0]
        if answer != self.answer:
            # Answer was presumably unlocked
            self.locked = False
            self.answer = answer

PK     ¶’IÏå$©²
  ²
     client/sources/ok_test/logic.py"""Console for interpreting Logic, a variant of the Prolog language. In
particular, this is meant to integrate with UC Berkeley CS 61A's Logic
interpreter. LogicConsole expects the an importable module called "logic" with
the following interface:

    logic.create_global_frame()
    logic.read_eval_print_loop(next_line_fn, frame, interactive)
    logic.buffer_input()
    logic.read_line(code)
    logic.process_input(exp, env)
    logic.facts
"""

from client import exceptions
from client.sources.common import interpreter
from client.sources.ok_test import doctest
from client.utils import output
from client.utils import timer
import importlib
import sys
import textwrap
import traceback

class LogicConsole(interpreter.Console):
    PS1 = 'logic> '
    PS2 = '...... '

    MODULE = 'logic'
    _output_fn = str

    def load(self, code, setup='', teardown=''):
        """Prepares a set of setup, test, and teardown code to be
        run in the console.

        Loads the Logic module before loading any code.
        """
        self._import_logic()
        super().load(code, setup, teardown)
        self._frame = self.logic.create_global_frame()

    def interact(self):
        """Opens up an interactive session with the current state of
        the console.
        """
        self.logic.read_eval_print_loop(self.logic.buffer_input, self._frame,
                                         True)

    def evaluate(self, code):
        if not code.strip():
            # logic.scheme_read can't handle empty strings.
            return None, ''
        log_id = output.new_log()
        try:
            exp = self.logic.read_line(code)
            result = timer.timed(self.timeout, self.logic.scheme_eval,
                                 (exp, self._frame))
        except RuntimeError as e:
            stacktrace_length = 15
            stacktrace = traceback.format_exc().strip().split('\n')
            print('Traceback (most recent call last):\n  ...')
            print('\n'.join(stacktrace[-stacktrace_length:]))
            raise interpreter.ConsoleException(e)
        except exceptions.Timeout as e:
            print('# Error: evaluation exceeded {} seconds.'.format(e.timeout))
            raise interpreter.ConsoleException(e)
        except Exception as e:
            stacktrace = traceback.format_exc()
            token = '<module>\n'
            index = stacktrace.rfind(token) + len(token)
            stacktrace = stacktrace[index:].rstrip('\n')
            if '\n' in stacktrace:
                print('Traceback (most recent call last):')
            print(stacktrace)
            raise interpreter.ConsoleException(e)
        else:
            printed_output = ''.join(output.get_log(log_id))
            return result, printed_output
        finally:
            output.remove_log(log_id)

    def _import_logic(self):
        try:
            sys.path.insert(0, 'logic')
            self.logic = importlib.import_module(self.MODULE)
        except ImportError as e:
            raise exceptions.ProtocolException('Could not import logic')

    def _reset_logic(self):
        """The Logic interpreter needs to be reset before running a suite.
        All mutable global variables should be reset.
        """
        self.logic.facts[:] = []

class LogicSuite(doctest.DoctestSuite):
    console_type = LogicConsole

    def run(self, test_name, suite_number, env=None):
        self.console._reset_logic()
        return super().run(test_name, suite_number, env)
PK     FI               client/cli/__init__.pyPK     FIw’Àˆ;  ;     client/cli/ok.py"""This file is responsible for coordinating all of OK's protocols."""

from client import exceptions as ex
from client.api import assignment
from client.cli.common import messages
from client.utils import auth
from client.utils import output
from client.utils import software_update
from datetime import datetime
import argparse
import client
import logging
import os
import sys
import struct

LOGGING_FORMAT = '%(levelname)s  | %(filename)s:%(lineno)d | %(message)s'
logging.basicConfig(format=LOGGING_FORMAT)
log = logging.getLogger('client')   # Get top-level logger

CLIENT_ROOT = os.path.dirname(client.__file__)

##########################
# Command-line Interface #
##########################

def parse_input(command_input=None):
    """Parses command line input."""
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    # Protocol parameters
    parser.add_argument('-q', '--question', type=str, action='append',
                        help="focus on specific questions")
    parser.add_argument('-u', '--unlock', action='store_true',
                        help="unlock tests interactively")
    parser.add_argument('-i', '--interactive', action='store_true',
                        help="toggle interactive mode")
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="print more output")
    parser.add_argument('--all', action='store_true',
                        help="run tests for all questions in config file")
    parser.add_argument('--submit', action='store_true',
                        help="Submit assignment")
    parser.add_argument('--backup', action='store_true',
                        help="Backup assignment reliably")
    parser.add_argument('--revise', action='store_true',
                        help="Submit composition revision")
    parser.add_argument('--restore', action='store_true',
                        help="Restore assignment from an earlier backup")
    parser.add_argument('--lock', action='store_true',
                        help="partial path to directory to lock")
    parser.add_argument('--score', action='store_true',
                        help="Scores the assignment")
    parser.add_argument('--score-out', type=argparse.FileType('w'),
                        default=sys.stdout, help="file to write scores to")
    parser.add_argument('--config', type=str,
                        help="Specify a configuration file")
    parser.add_argument('--timeout', type=int, default=60,
                        help="set the timeout duration for running tests")

    # Hinting Protocol
    parser.add_argument('--no-hints', action='store_true',
                        help="Do not run Hinting Protocol")
    parser.add_argument('--hint', action='store_true',
                        help="Run hinting protocol and compute hint (if available)")

    # Autostyle
    parser.add_argument('--style', action='store_true',
                        help="Run AutoStyle Feedback System")
    # Submission Export
    parser.add_argument('--export', action='store_true',
                        help="Downloads all submissions for the current assignment")
    parser.add_argument('--latest', action='store_true',
                        help="When used with --export, downloads latest submissions instead of final submissions")

    # Debug information
    parser.add_argument('--version', action='store_true',
                        help="Prints the version number and quits")
    parser.add_argument('--tests', action='store_true',
                        help="display a list of all available tests")
    parser.add_argument('--debug', action='store_true',
                        help="show debug statements")

    # Server parameters
    parser.add_argument('--local', action='store_true',
                        help="disable any network activity")
    parser.add_argument('--server', type=str,
                        default='ok.cs61a.org',
                        help="server address")
    parser.add_argument('--authenticate', action='store_true',
                        help="authenticate, ignoring previous authentication")
    parser.add_argument('--get-token', action='store_true',
                        help="gets ok access token")
    parser.add_argument('--insecure', action='store_true',
                        help="uses http instead of https")
    parser.add_argument('--no-update', action='store_true',
                        help="turns off software updating")
    parser.add_argument('--update', action='store_true',
                        help="checks and performs software update then exits")

    if command_input is None:
        return parser.parse_args()
    else:
        return parser.parse_args(command_input)

def main():
    """Run all relevant aspects of ok.py."""
    args = parse_input()

    log.setLevel(logging.DEBUG if args.debug else logging.ERROR)
    log.debug(args)

    # Checking user's Python bit version
    bit_v = (8 * struct.calcsize("P"))
    log.debug("Python {}bit".format(bit_v))

    if args.version:
        print("okpy=={}".format(client.__version__))
        exit(0)
    elif args.update:
        print("Current version: {}".format(client.__version__))
        did_update = software_update.check_version(
                args.server, client.__version__, client.FILE_NAME, timeout=10)
        exit(not did_update)  # exit with error if ok failed to update

    if args.get_token:
        access_token = auth.authenticate(True)
        print("Token: {}".format(access_token))
        exit(not access_token)  # exit with error if no access_token

    assign = None
    try:
        if args.authenticate:
            # Authenticate and check for success
            if not auth.authenticate(True):
                exit(1)

        # Instantiating assignment
        assign = assignment.load_assignment(args.config, args)

        if args.tests:
            print('Available tests:')
            for name in assign.test_map:
                print('    ' + name)
            exit(0)

        msgs = messages.Messages()
        for name, proto in assign.protocol_map.items():
            log.info('Execute {}.run()'.format(name))
            proto.run(msgs)

        msgs['timestamp'] = str(datetime.now())

    except ex.LoadingException as e:
        log.warning('Assignment could not load', exc_info=True)
        print('Error loading assignment: ' + str(e))
    except ex.AuthenticationException as e:
        log.warning('Authentication exception occurred', exc_info=True)
        print('Authentication error: {0}'.format(e))
    except ex.OkException as e:
        log.warning('General OK exception occurred', exc_info=True)
        print('Error: ' + str(e))
    except KeyboardInterrupt:
        log.info('KeyboardInterrupt received.')
    finally:
        if not args.no_update:
            try:
                software_update.check_version(args.server, client.__version__,
                                              client.FILE_NAME)
            except KeyboardInterrupt:
                pass

        if assign:
            assign.dump_tests()


if __name__ == '__main__':
    main()
PK     ,}ÔH‹Û6V  V     client/cli/common/messages.pyclass Messages(dict):
    """A subclass of dictionary that prints a warning when an existing is
    overwritten.
    """
    def __setitem__(self, key, value):
        if key in self:
            print('Warning: Overwriting key {}. '
                  'Old: {}; New: {}'.format(key, self[key], value))
        super().__setitem__(key, value)
PK     ,}ÔH               client/cli/common/__init__.pyPK     c·ÿHõL¯Ú       client/utils/format.py"""Formatting utilities."""

from client import exceptions
import textwrap
from contextlib import contextmanager

#############
# Whtespace #
#############

def dedent(text):
    """Dedents a string of text.

    Leading whitespace that is common to all lines in the string is
    removed. Any leading newlines and trailing whitespace is also
    removed.
    """
    return textwrap.dedent(text).lstrip('\n').rstrip()

def indent(text, indentation):
    """Indents a string of text with the given string of indentation.

    PARAMETERS:
    text        -- str
    indentation -- str; prefix of indentation to add to the front of
                   every new line.

    RETURNS:
    str; the newly indented string.
    """
    return '\n'.join([indentation + line for line in text.splitlines()])

def normalize(text):
    """Normalizes whitespace in a specified string of text."""
    return " ".join(text.strip().split())

############
# Printing #
############

def print_line(style, length=69):
    """Prints an underlined version of the given line with the
    specified underline style.

    PARAMETERS:
    style  -- str; a one-character string that denotes the line style.
    length -- int; the width of the line. The default is 69, which is the width
              for doctest lines.
    """
    print(style * length)

@contextmanager
def block(style, length=69):
    """Print a block with the specified style.
    USAGE:
    with block('-'):
        print("Hello")
    """
    print_line(style, length)
    yield
    print_line(style, length)

def print_progress_bar(header, passed, failed, locked, verbose=True):
    print_line('-')
    print(header)
    if locked > 0:
        print('    Locked: {}'.format(locked))
    if verbose:
        print('    Passed: {}'.format(passed))
        print('    Failed: {}'.format(failed))
    elif failed > 0:
        print('    {} test cases passed before encountering '
              'first failed test case'.format(passed))
        return
    else:
        print('    {} test cases passed! No cases failed.'.format(passed))
        return

    # Print [oook.....] progress bar
    total = passed + failed + locked
    percent = round(100 * passed / total, 1) if total != 0 else 0.0
    print('[{}k{}] {}% passed'.format(
        'o' * int(percent // 10),
        '.' * int(10 - (percent // 10)),
        percent))

#################
# Serialization #
#################

def prettyjson(json, indentation='  '):
    """Formats a Python-object into a string in a JSON like way, but
    uses triple quotes for multiline strings.

    PARAMETERS:
    json        -- Python object that is serializable into json.
    indentation -- str; represents one level of indentation

    NOTES:
    All multiline strings are treated as raw strings.

    RETURNS:
    str; the formatted json-like string.
    """
    if isinstance(json, int) or isinstance(json, float):
        return str(json)
    elif isinstance(json, str):
        if '\n' in json:
            return 'r"""\n' + dedent(json) + '\n"""'
        return repr(json)
    elif isinstance(json, list):
        lst = [indent(prettyjson(el, indentation), indentation) for el in json]
        return '[\n' + ',\n'.join(lst) + '\n]'
    elif isinstance(json, dict):
        pairs = []
        for k, v in sorted(json.items()):
            k = prettyjson(k, indentation)
            v = prettyjson(v, indentation)
            pairs.append(indent(k + ': ' + v, indentation))
        return '{\n' + ',\n'.join(pairs) + '\n}'
    else:
        raise exceptions.SerializeException('Invalid json type: {}'.format(json))

PK     ,}ÔHö ¨ð0  0     client/utils/software_update.pyimport json
import logging
import os
import urllib.error
import urllib.request
from socket import error as socket_error

log = logging.getLogger(__name__)

VERSION_ENDPOINT = 'https://{server}/api/v3/version/ok-client'

SHORT_TIMEOUT = 3  # seconds

def check_version(server, version, filename, timeout=SHORT_TIMEOUT):
    """Check for the latest version of OK and update accordingly."""

    address = VERSION_ENDPOINT.format(server=server)

    print('Checking for software updates...')
    log.info('Existing OK version: %s', version)
    log.info('Checking latest version from %s', address)

    try:
        request = urllib.request.Request(address)
        response = urllib.request.urlopen(request, timeout=timeout)
    except (urllib.error.HTTPError, urllib.error.URLError, socket_error) as e:
        print('Network error when checking for updates.')
        log.warning('Network error when checking version from %s: %s', address,
                    str(e), stack_info=True)
        return False

    response_json = json.loads(response.read().decode('utf-8'))
    if not _validate_api_response(response_json):
        print('Error while checking updates: malformed server response')
        log.info('Malformed response from %s: %s', address,
                 json.dumps(response_json))
        return False

    current_version = response_json['data']['results'][0]['current_version']
    if current_version == version:
        print('OK is up to date')
        return True

    download_link = response_json['data']['results'][0]['download_link']

    log.info('Downloading version %s from %s', current_version, download_link)

    try:
        request = urllib.request.Request(download_link)
        response = urllib.request.urlopen(request, timeout=timeout)
    except (urllib.error.HTTPError, urllib.error.URLError, socket_error) as e:
        print('Error when downloading new version of OK')
        log.warning('Error when downloading new version of OK: %s', str(e),
                    stack_info=True)
        return False

    log.info('Writing new version to %s', filename)

    zip_binary = response.read()
    try:
        _write_zip(filename, zip_binary)
    except IOError as e:
        print('Error when downloading new version of OK')
        log.warning('Error writing to %s: %s', filename, str(e))
        return False
    else:
        print('Updated to version: {}'.format(current_version))
        log.info('Successfully wrote to %s', filename)
        return True

def _validate_api_response(data):
    return isinstance(data, dict) and \
           'data' in data and \
           isinstance(data['data'], dict) and \
           'results' in data['data'] and \
           isinstance(data['data']['results'], list) and \
           len(data['data']['results']) > 0 and \
           isinstance(data['data']['results'][0], dict) and \
           'current_version' in data['data']['results'][0] and \
           'download_link' in data['data']['results'][0]



def _write_zip(zip_name, zip_contents):
    with open(zip_name, 'wb') as f:
        f.write(zip_contents)
        os.fsync(f)
PK     ,}ÔHÅë=B6	  6	     client/utils/html.py
auth_html = """
<html>
<head>
    <title>Okpy</title>
    <link href="http://ok-server.appspot.com/static/student/styles/auth.css" rel="stylesheet">
    {head}
</head>
<body>
<header>
    <div class="logo">
        <img src="http://ok-server.appspot.com/static/student/images/logo-light.png">
        <h1>Okpy</h1>
    </div>
    <nav>
        <ul>
            <li><a href="{site}">Dashboard</a></li>
        </ul>
    </nav>
</header>
<section class="top center-container" style="height:50%">
    <div class="center">
        <h1 class="title">{title}</h1>
        <h2 class="subtitle">{byline}</h2>
        <span class="break">
        <a href="{site}" class="button">Dashboard</a>
        <p class="copy">or <a href="http://cs61a.org/articles/using-ok.html">Read the FAQ</a></p>
        </span>
    </div>
</section>
<div class="rise status">{status}</div>
<section class="courses">
    <div class="wrap row" style="width:100%">
        {courses}
    </div>
</section>
<footer>
    <h3>okpy</h3>
    <p><a href="http://cs61a.org">cs61a.org</a> . <a href="http://composingprograms.com">composingprograms.com</a> . <a href="https://github.com/Cal-CS-61A-Staff/ok">github repo</a></p>
</footer>
</body>
<link href='https://fonts.googleapis.com/css?family=Roboto:400|Roboto+Condensed' rel='stylesheet'
      type='text/css'>
</html>
"""

partial_course_html = """
<div class="col-md-3" style="width: 30%;margin: 10px;">
    <div class="blob colored" color="blue">
        <div class="blob-main attn">
            <h2 class="blob-title ng-binding">{display_name}</h2>
            <p class="blob-shiftcopy blob-copy ng-binding"><span class="icon-tag"></span>{offering}</p>
        </div>
        <a href="https://okpy.org/{offering}">
            <div class="blob-action">View Course
                <span class="white arrow right"></span>
            </div>
        </a>
    </div>
</div>
"""

partial_nocourse_html = """
<div class="empty">
    <p>It looks like this email is not enrolled in any courses. Double-check to make sure that you submitted with the correct address.</p>
</div>
"""

red_css=  """
.top.center-container {
    background-color:rgb(239, 95, 86)
}

.top .center .button {
    background-color:rgb(171, 49, 44)
}
    .top .center .button:hover {
        background-color:#701d17
    }

.rise.status {
    background-color:#701d17;
}
"""
PK     ,}ÔH5Ðtà   à      client/utils/locking.py"""Used for locking answers in tests."""

import hmac

def lock(key, text):
    """Locks the given text using the given key and returns the result"""
    return hmac.new(key.encode('utf-8'), text.encode('utf-8')).hexdigest()PK     ,}ÔHaÞÈ ©  ©     client/utils/output.py"""This module contains code related to controlling and writing to stdout."""

import os
import sys

class _OutputLogger(object):
    """Custom logger for capturing and suppressing standard output."""
    # TODO(albert): logger should fully implement output stream.

    def __init__(self):
        self._current_stream = self._stdout = sys.stdout
        self._devnull = open(os.devnull, 'w')
        self._logs = {}
        self._num_logs = 0

    def on(self):
        """Allows print statements to emit to standard output."""
        self._current_stream = self._stdout

    def off(self):
        """Prevents print statements from emitting to standard out."""
        self._current_stream = self._devnull

    def new_log(self):
        """Registers a new log so that calls to write will append to the log.

        RETURN:
        int; a unique ID to reference the log.
        """
        log_id = self._num_logs
        self._logs[log_id] = []
        self._num_logs += 1
        return log_id

    def get_log(self, log_id):
        assert log_id in self._logs
        return self._logs[log_id]

    def remove_log(self, log_id):
        assert log_id in self._logs, 'Log id {} not found'.format(log_id)
        del self._logs[log_id]

    def remove_all_logs(self):
        self._logs = {}

    def is_on(self):
        return self._current_stream == self._stdout

    def write(self, msg):
        """Writes msg to the current output stream (either standard
        out or dev/null). If a log has been registered, append msg
        to the log.

        PARAMTERS:
        msg -- str
        """
        self._current_stream.write(msg)
        for log in self._logs.values():
            log.append(msg)

    def flush(self):
        self._current_stream.flush()

    # TODO(albert): rewrite this to be cleaner.
    def __getattr__(self, attr):
        return getattr(self._current_stream, attr)

_logger = sys.stdout = _OutputLogger()

def on():
    _logger.on()

def off():
    _logger.off()

def get_log(log_id):
    return _logger.get_log(log_id)

def new_log():
    return _logger.new_log()

def remove_log(log_id):
    _logger.remove_log(log_id)

def remove_all_logs():
    _logger.remove_all_logs()
PK      ½ÝH~	&‹<  ‹<     client/utils/guidance.pyfrom client.utils import auth
from client.utils import assess_id_util

import hashlib
import json
import logging
import os
from urllib.request import urlopen
log = logging.getLogger(__name__)

"""
This utility is called by unlock.py. This guidance utility changes the message that students see
after they input in wrong answers. If a student guesses a certain amount of wrong answers
that shows a certain type of confusion about the problem, this utility will instead of showing
the default "Not Quite Try Again" message will show some kind of message that will target
that type of misunderstanding.

This utility object requires internet access to determine what treatment group they are assigned
to. The different treatment groups will have varying threshold level of answers as well as different
messages and other differences. It will contact the server defined below in the variable TGSERVER with
the user's email and lab assignment to get the treatment group number.

Commonly used acronyms:
TG = treatment group number
KI = Type of targeted understanding
misU = Type of misunderstanding the student is showing
wa = wrong answer

The LOCAL_TG_FILE will hold what treatment group number the student is part of.
The OK_GUIDANCE_FILE will facilitate the generation of guided messages. It will hold the necessary info
to know what type of misunderstanding an answer has as well as what guidance message to show.
"""
TGSERVER = "https://tg-server.app.cs61a.org/"
TG_SERVER_ENDING = "/unlock_tg"

LOCAL_TG_FILE = "tests/tg.ok_tg"
OK_GUIDANCE_FILE = "tests/.ok_guidance"
GUIDANCE_DEFAULT_MSG = "-- Not quite. Try again! --"
EMPTY_MISUCOUNT_TGID_PRNTEDMSG = ({}, -1, [])
COUNT_FILE_PATH = "tests/misUcount.json"
TG_CONTROL = 0
# If student forces guidance messages to show, we will assign treatment
# group number below
GUIDANCE_FLAG_TG_NUMBER = 1
# If set_tg() fails, we will default to this treatment group number
TG_ERROR_VALUE = -1

# These lambda functions allow us to map from a certain type of misunderstanding to
# the desired targeted guidance message we want to show.
# lambda for control or treatment group where we want nothing to happen
# Knowledge integration treatment group lambda that is answer specific
# lambda for returning an answer + misunderstanding specific message

lambda_string_key_to_func = {
    'none': lambda info, strMisU: None,
    'ki': lambda info, strMisU: info['ki'],
    'misU2Msg': lambda info, strMisU: info['dictMisU2Msg'].get(strMisU),
    'tag2KIMsg': lambda info, strMisU: info['dictTag2KIMsg'].get(strMisU),
    'tag2ConceptMsg': lambda info, strMisU: info['dictTag2ConceptMsg'].get(strMisU)
}

class Guidance:
    def __init__(self, current_working_dir, assignment=None):
        """
        Initializing everything we need to the default values. If we catch
        an error when opening the JSON file, we flagged it as error.
        """
        self.tg_id = -1

        self.assignment = assignment
        if assignment:
            self.assignment_name = assignment.name.replace(" ", "")
        else:
            self.assignment_name = ""

        self.current_working_dir = current_working_dir
        try:
            with open(current_working_dir + OK_GUIDANCE_FILE, "r") as f:
                self.guidance_json = json.load(f)
            self.load_error = False
            if not self.validate_json():
                raise ValueError("JSON did not validate")
            self.guidance_json = self.guidance_json['db']
        except (OSError, IOError, ValueError):
            log.warning("Failed to read .ok_guidance file. It may not exist")
            self.load_error = True
        log.debug("Guidance loaded with status: %s", not self.load_error)

    def validate_json(self):
        """ Ensure that the checksum matches. """
        if not hasattr(self, 'guidance_json'):
            return False

        checksum = self.guidance_json.get('checksum')
        contents = self.guidance_json.get('db')

        hash_key = ("{}{}".format(json.dumps(contents, sort_keys=True),
                                  self.assignment.endpoint).encode())

        digest = hashlib.md5(hash_key).hexdigest()

        if not checksum:
            log.warning("Checksum on guidance not found. Invalidating file")
            return False
        if digest != checksum:
            log.warning("Checksum %s did not match digest", checksum)
            return False
        return True

    def get_aid_from_anum(self, num):
        """ Return the unique id (str) from the assesment id number. """
        return self.guidance_json['dictAssessNum2AssessId'].get(num)

    def show_guidance_msg(self, unique_id, input_lines, access_token, hash_key,
                          guidance_flag=False):
        """
        Based on the student's answer (input_lines), we grab each associated
        message if its corresponding misunderstanding's count is above the threshold
        """
        if self.load_error:
            print(GUIDANCE_DEFAULT_MSG)
            return EMPTY_MISUCOUNT_TGID_PRNTEDMSG

        response = repr(input_lines)
        self.set_tg(access_token)
        log.info("Guidance TG is %d", self.tg_id)

        if self.tg_id == TG_ERROR_VALUE:
            # If self.tg_id == -1, there was an error when trying to access the server
            log.warning("Error when trying to access server. TG == -1")
            print(GUIDANCE_DEFAULT_MSG)
            return EMPTY_MISUCOUNT_TGID_PRNTEDMSG

        lambda_string_key = self.guidance_json[
            'dictTg2Func'].get(str(self.tg_id))

        if not lambda_string_key:
            log.info("Cannot find the correct lambda in the dictionary.")
            print(GUIDANCE_DEFAULT_MSG)
            return EMPTY_MISUCOUNT_TGID_PRNTEDMSG
        log.info("Lambda Group: %s", lambda_string_key)

        lambda_info_misu = lambda_string_key_to_func.get(lambda_string_key)
        if not lambda_info_misu:
            log.info("Cannot find info misU given the lambda string key.")
            print(GUIDANCE_DEFAULT_MSG)
            return EMPTY_MISUCOUNT_TGID_PRNTEDMSG

        shorten_unique_id = assess_id_util.canonicalize(unique_id)
        # Try to get the info dictionary for this question. Maps wrong answer
        # to dictionary
        assess_dict_info = self.guidance_json[
            'dictAssessId2Info'].get(shorten_unique_id)
        if not assess_dict_info:
            log.info("shorten_unique_id %s is not in dictAssessId2Info", repr(shorten_unique_id))
            print(GUIDANCE_DEFAULT_MSG)
            return EMPTY_MISUCOUNT_TGID_PRNTEDMSG

        wa_details = assess_dict_info['dictWA2DictInfo'].get(response)
        if not wa_details:
            log.info("Cannot find the wrong answer in the WA2Dict for this assesment.")
            lst_mis_u = []
        else:
            lst_mis_u = wa_details.get('lstMisU', [])

        # No list of misunderstandings for this wrong answer, default message
        if not lst_mis_u:
            log.info("Cannot find the list of misunderstandings.")

        wa_count_threshold = self.guidance_json['wrongAnsThresh']
        wa_lst_assess_num = assess_dict_info['dictWA2LstAssessNum_WA']
        msg_id_set = set()

        answerDict, countData = self.get_misUdata()
        prev_responses = answerDict.get(shorten_unique_id, [])

        # Confirm that this WA has not been given before
        seen_before = response in prev_responses
        if seen_before:
            log.info("Answer has been seen before: {}".format(response))
        else:
            answerDict[shorten_unique_id] = prev_responses + [response]
            self.save_misUdata(answerDict, countData)

            # Lookup the list of assessNum and WA related to this wrong answer
            # in the question's dictWA2LstAssessNum_WA
            lst_assess_num = wa_lst_assess_num.get(response, [])
            if not lst_assess_num:
                log.info("Cannot get the lst of assess nums given this reponse.")
            log.debug("Related LST_ASSESS_NUM: %s", lst_assess_num)

            # Check if the current wrong answer is in the question's dictWA2DictInfo
            if wa_details:
                log.info("The current wrong answer (%s) is in dictWA2DictInfo", response)
                # Check in answerDict to see if the student has ever given
                # any of these wrong answers (sourced from dictWA2LstAssessNum_WA)
                num_prev_responses = 1

                for other_num, other_resp in lst_assess_num:
                    # Get assess_id
                    other_id = self.get_aid_from_anum(other_num)
                    log.info("Checking if %s is in answerDict[%s]", other_resp, repr(other_id))
                    if other_resp in answerDict.get(other_id, []):
                        log.debug("%s is in answerDict[%s]", other_resp, repr(other_id))
                        num_prev_responses += 1

                log.info("Has given %d previous responses in lst_assess_num", num_prev_responses)

                # Increment countDict by the number of wrong answers seen
                # for each tag assoicated with this wrong answer
                increment = num_prev_responses
                for misu in lst_mis_u:
                    log.info("Updating the count of misu: %s by %s", misu, increment)
                    countData[misu] = countData.get(misu, 0) + increment

                for misu in lst_mis_u:
                    log.debug("Misu: %s has count %s", misu, countData[misu])
                    if countData[misu] >= wa_count_threshold:
                        msg_info = lambda_info_misu(wa_details, misu)
                        if msg_info:
                            msg_id_set.add(msg_info)
            else:
                # Lookup the lst_mis_u of each wrong answer in the list of wrong
                # answers related to the current wrong answer (lst_assess_num),
                # using dictAssessNum2AssessId
                assess_num_to_aid = self.guidance_json['dictAssessNum2AssessId']
                log.debug("Looking up the lst_misu_u of all related WA")

                # misu -> list of wrong answers for that
                related_misu_tags_dict = {}

                for related_num, related_resp in lst_assess_num:
                    related_aid = assess_num_to_aid.get(related_num)
                    log.info("Getting related resp %s for AID %s", repr(related_aid), related_resp)
                    resp_seen_before = related_resp in answerDict.get(related_aid, [])

                    if not resp_seen_before:
                      continue

                    # Get the lst_misu for this asssigmment
                    related_info = self.guidance_json['dictAssessId2Info'].get(related_aid)
                    if not related_info:
                        log.info("Could not find related id: %s in info dict",
                                 related_aid)
                        continue
                    related_wa_info = related_info['dictWA2DictInfo'].get(related_resp)

                    if not related_info:
                        log.info("Could not find response %s in %s info dict",
                                 related_resp, related_aid)
                        continue

                    related_misu_list = related_wa_info.get('lstMisU', [])
                    log.info("The related MISU list is %s", related_misu_list)

                    for misu in related_misu_list:
                        existing_resps = related_misu_tags_dict.get(misu, [])
                        # Add dictWA2DictInfo to list of responses for this misunderstanding.
                        related_misu_tags_dict[misu] = existing_resps + [related_wa_info]
                        # Increment countDict for each tag in the set of tags for each related resp
                        countData[misu] = countData.get(misu, 0) + 1

                    for misu, lst_wa_info in related_misu_tags_dict.items():
                        if countData[misu] >= wa_count_threshold:
                            for wa_info in lst_wa_info:
                                msg_id_set.add(lambda_info_misu(wa_info, misu))
                        else:
                            log.info("misu %s seen %s/%s times",
                                     misu, countData[misu], wa_count_threshold)


        self.save_misUdata(answerDict, countData)

        if len(msg_id_set) == 0:
            log.info("No messages to display.")
            print(GUIDANCE_DEFAULT_MSG)
            return (countData, self.tg_id, [])

        print("\n-- Helpful Hint --")

        printed_out_msgs = []
        for message_id in msg_id_set:
            msg = self.guidance_json['dictId2Msg'].get(str(message_id))
            if msg:
                printed_out_msgs.append(msg)
                print(msg)
                print("-"*18)
            else:
                log.info("{} did not have a message".format(message_id))
        print()
        print(GUIDANCE_DEFAULT_MSG)

        return (countData, self.tg_id, printed_out_msgs)

    def get_misUdata(self):
        # Creates a new folder inside tests that stores the number of misU per
        # assignment
        if os.path.isfile(self.current_working_dir + COUNT_FILE_PATH):
            with open(self.current_working_dir + COUNT_FILE_PATH, 'r') as f:
                jsonDic = json.load(f)
                answerDict = jsonDic["answerDict"]
                countData = jsonDic["countData"]
        else:
            countData = {}
            answerDict = {}

        return answerDict, countData

    def save_misUdata(self, answerDict, countData):
        data = {
            "countData": countData,
            "answerDict": answerDict
        }
        log.info("Attempting to save response/count dict")
        with open(self.current_working_dir + COUNT_FILE_PATH, "w") as f:
            json.dump(data, f)
        return data

    def set_tg(self, access_token):
        """ Try to grab the treatment group number for the student.
        If there is no treatment group number available, request it
        from the server.
        """
        # Checks to see the student currently has a treatment group number. If
        # not, calls helper function in auth.py
        if not os.path.isfile(self.current_working_dir + LOCAL_TG_FILE):
            cur_email = auth.get_student_email(access_token)
            log.info("Current email is %s", cur_email)
            if not cur_email:
                self.tg_id = -1
                return EMPTY_MISUCOUNT_TGID_PRNTEDMSG

            tg_url = ("{}{}/{}{}"
                      .format(TGSERVER, cur_email, self.assignment_name,
                              TG_SERVER_ENDING))
            try:
                log.info("Accessing treatment server at %s", tg_url)
                data = json.loads((urlopen(tg_url, timeout=1).read()
                                                             .decode("utf-8")))
            except IOError:
                data = {"tg": -1}
                log.warning("Failed to communicate to server", exc_info=True)

            if data.get("tg") is None:
                log.warning("Server returned back a bad treatment group ID.")
                data = {"tg": -1}

            with open(self.current_working_dir + LOCAL_TG_FILE, "w") as fd:
                fd.write(str(data["tg"]))

        tg_file = open(self.current_working_dir + LOCAL_TG_FILE, 'r')
        self.tg_id = int(tg_file.read())
PK     ,}ÔHêñÜ%/  /     client/utils/network.py"""This module contains utilities for communicating with the ok server."""

from urllib import request, error
import json
import logging

log = logging.getLogger(__name__)

TIMEOUT = 15

def api_request(access_token, server, route, insecure=False, arguments={}):
    """Makes a request to the server API and returns the result."""
    try:
        prefix = "http" if insecure else "https"
        address = prefix + "://" + server + '/api/v3'
        address += route if route.startswith('/') else '/' + route
        address += "?access_token={0}".format(
            access_token)
        for arg in arguments:
            address += "&{0}={1}".format(arg, arguments[arg])
        log.info('Requesting data from %s', address)
        req = request.Request(address)
        arguments = []
        response = request.urlopen(req, None, TIMEOUT)
        return json.loads(response.read().decode('utf-8'))
    except error.HTTPError as ex:
        log.warning('Error while requesting from server: %s', str(ex))
        response = ex.read().decode('utf-8')
        response_json = json.loads(response)
        log.warning('Server error message: %s', response_json['message'])
        if ex.code == 401:
            print("Only members of the course staff can access this feature.")
            return
        return response_json
PK     ,}ÔH               client/utils/__init__.pyPK     c·ÿH¤%[²¯,  ¯,     client/utils/auth.py#!/usr/bin/env python3

import http.server

import json
import hashlib
import os
import pickle
import time
from urllib.parse import urlparse, parse_qs
from urllib.request import urlopen
import webbrowser

from client.exceptions import AuthenticationException
from client.utils.html import (auth_html, partial_course_html,
                               partial_nocourse_html, red_css)
from client.utils.sanction import Client

import logging

log = logging.getLogger(__name__)

CLIENT_ID = ('931757735585-vb3p8g53a442iktc4nkv5q8cbjrtuonv'
             '.apps.googleusercontent.com')

# The client secret in an installed application isn't a secret.
# See: https://developers.google.com/accounts/docs/OAuth2InstalledApp
CLIENT_SECRET = 'zGY9okExIBnompFTWcBmOZo4'

CONFIG_DIRECTORY = os.path.join(os.path.expanduser('~'), '.config', 'ok')

REFRESH_FILE = os.path.join(CONFIG_DIRECTORY, "auth_refresh")

REDIRECT_HOST = "127.0.0.1"
REDIRECT_PORT = 6165

TIMEOUT = 10
SERVER = 'https://ok.cs61a.org'
INFO_ENDPOINT = "https://www.googleapis.com/oauth2/v1/userinfo?access_token={}"


def pick_free_port(hostname=REDIRECT_HOST, port=0):
    """ Try to bind a port. Default=0 selects a free port. """
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.bind((hostname, port))  # port=0 finds an open port
    except OSError as e:
        log.warning("Could not bind to %s:%s %s", hostname, port, e)
        if port == 0:
            print('Unable to find an open port for authentication.')
            raise AuthenticationException(e)
        else:
            return pick_free_port(hostname, 0)
    addr, port = s.getsockname()
    s.close()
    return port

def _make_code_post(code, redirect_uri):
    client = Client(
        token_endpoint='https://accounts.google.com/o/oauth2/token',
        resource_endpoint='https://www.googleapis.com/oauth2/v1',
        client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
    params = {"redirect_uri": redirect_uri}
    client.request_token(code=code, **params)
    return client.access_token, client.refresh_token, client.expires_in


def make_refresh_post(refresh_token):
    client = Client(
        token_endpoint='https://accounts.google.com/o/oauth2/token',
        resource_endpoint='https://www.googleapis.com/oauth2/v1',
        client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
    params = {"grant_type": "refresh_token"}
    client.request_token(refresh_token=refresh_token, **params)
    return client.access_token, client.expires_in


def create_config_directory():
    if not os.path.exists(CONFIG_DIRECTORY):
        os.makedirs(CONFIG_DIRECTORY)


def get_storage():
    create_config_directory()
    with open(REFRESH_FILE, 'rb') as fp:
        storage = pickle.load(fp)

    access_token = storage['access_token']
    expires_at = storage['expires_at']
    refresh_token = storage['refresh_token']

    return access_token, expires_at, refresh_token


def update_storage(access_token, expires_in, refresh_token):
    if not (access_token and expires_in and refresh_token):
        raise AuthenticationException(
            "Authentication failed and returned an empty token.")

    cur_time = int(time.time())
    create_config_directory()
    with open(REFRESH_FILE, 'wb') as fp:
        pickle.dump({
            'access_token': access_token,
            'expires_at': cur_time + expires_in,
            'refresh_token': refresh_token
        }, fp)


def check_ssl():
    try:
        import ssl
    except:
        log.warning('Error importing ssl', stack_info=True)
        raise Exception(
                'SSL Bindings are not installed. '
                'You can install python3 SSL bindings or run OK locally:\n'
                '\tpython3 ok --local')
    else:
        log.info('SSL bindings are available.')


def authenticate(force=False):
    """
    Returns an oauth token that can be passed to the server for identification.
    """
    if not force:
        try:
            cur_time = int(time.time())
            access_token, expires_at, refresh_token = get_storage()
            if cur_time < expires_at - 10:
                return access_token
            access_token, expires_in = make_refresh_post(refresh_token)

            if not access_token and expires_in:
                raise AuthenticationException(
                    "Authentication failed and returned an empty token.")

            update_storage(access_token, expires_in, refresh_token)
            return access_token
        except IOError as _:
            print('Performing authentication')
        except AuthenticationException as e:
            raise e  # Let the main script handle this error
        except Exception as _:
            print('Performing authentication')

    check_ssl()

    print("Please enter your bCourses email.")
    email = input("bCourses email: ")

    host_name = REDIRECT_HOST
    try:
        port_number = pick_free_port(port=REDIRECT_PORT)
    except AuthenticationException as e:
        # Could not bind to REDIRECT_HOST:0, try localhost instead
        host_name = 'localhost'
        port_number = pick_free_port(host_name, 0)

    redirect_uri = "http://{0}:{1}/".format(host_name, port_number)
    log.info("Authentication server running on {}".format(redirect_uri))

    c = Client(auth_endpoint='https://accounts.google.com/o/oauth2/auth',
               client_id=CLIENT_ID)
    url = c.auth_uri(scope="profile email", access_type='offline',
                     name='ok-server', redirect_uri=redirect_uri,
                     login_hint=email)

    webbrowser.open_new(url)

    done = False
    access_token = None
    refresh_token = None
    expires_in = None
    auth_error = None

    class CodeHandler(http.server.BaseHTTPRequestHandler):
        def send_failure(self, message):
            self.send_response(400)
            self.send_header("Content-type", "text/html")
            self.end_headers()
            self.wfile.write(bytes(failure_page(message), "utf-8"))

        def do_GET(self):
            """Respond to the GET request made by the OAuth"""
            nonlocal access_token, refresh_token, expires_in, auth_error, done

            path = urlparse(self.path)
            qs = parse_qs(path.query)
            try:
                code = qs['code'][0]
                code_response = _make_code_post(code, redirect_uri)
                access_token, refresh_token, expires_in = code_response
            except KeyError:
                message = qs.get('error', 'Unknown')
                log.warning("No auth code provided {}".format(message))
                auth_error = message
                done = True
                self.send_failure(message)
                return
            except Exception as e:  # TODO : Catch just SSL errors
                log.warning("Could not obtain token", exc_info=True)
                auth_error = e.message
                done = True
                self.send_failure(e.message)
                return

            done = True
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            self.end_headers()
            actual_email = email

            try:
                email_resp = get_student_email(access_token)
                if email_resp:
                    actual_email = email_resp
            except Exception as e:  # TODO : Catch just SSL errors
                log.warning("Could not get email from token", exc_info=True)

            reponse = success_page(SERVER, actual_email, access_token)
            self.wfile.write(bytes(reponse, "utf-8"))

        def log_message(self, format, *args):
            return

    server_address = (host_name, port_number)

    try:
        httpd = http.server.HTTPServer(server_address, CodeHandler)
        httpd.handle_request()
    except OSError as e:
        log.warning("HTTP Server Err {}".format(server_address), exc_info=True)
        raise

    if not auth_error:
        update_storage(access_token, expires_in, refresh_token)
        return access_token
    else:
        print("Authentication error: {}".format(auth_error))
        return None


def success_page(server, email, access_token):
    """ Generate HTML for the auth page.
        Fetches courses and plug into templates.
    """
    API = server + '/api/v3/enrollment/{0}/?access_token={1}'.format(
        email, access_token)
    try:
        data = urlopen(API).read().decode("utf-8")
        log.debug("Enrollment API {} resp: {}".format(API, data))
        success_data = success_courses(email, data, server)
    except:
        log.debug("Enrollment for {} failed".format(email), exc_info=True)
        return success_auth(success_courses(email, '[]', server))
    return success_auth(success_data)


def failure_page(error):
    html = partial_nocourse_html
    title = 'Authentication Error'
    byline = 'Error: {}'.format(error)
    status = 'We could not authenticate you.'
    head = '<style>{0}</style>'.format(red_css)
    return auth_html.format(
        site=SERVER,
        status=status,
        courses=html,
        byline=byline,
        title=title,
        head=head)


def success_courses(email, response, server):
    """Generates HTML for individual courses"""
    response = json.loads(response)

    if response and response['data'].get('courses', []):
        courses = response['data']['courses']
        template_course = partial_course_html
        html = ''
        for course in courses:
            html += template_course.format(**course['course'])

        status = "Scroll for more: {0}".format(
            ', '.join(course['course']['display_name'] for course in courses))
        byline = '"{}" is currently enrolled in {}.'.format(
            email, pluralize(len(courses), ' course'))
        title = 'Ok!'
        head = ''
    else:
        html = partial_nocourse_html
        byline = 'The email "{}" is not enrolled. Is it correct?'.format(email)
        status = 'No courses found'
        title = 'Uh oh'
        head = '<style>{0}</style>'.format(red_css)
    return html, status, byline, title, head, server


def success_auth(data):
    """Generates finalized HTML"""
    return auth_html.format(
        site=data[5],
        status=data[1],
        courses=data[0],
        byline=data[2],
        title=data[3],
        head=data[4])

def get_file(relative_path, purpose):
    dir = os.path.dirname(__file__)
    filename = os.path.join(dir, relative_path)
    return open(filename, purpose)

def get_contents(relative_path, purpose='r'):
    return get_file(relative_path, purpose).read()

def pluralize(num, string):
    return str(num)+string+('s' if num != 1 else '')

# Grabs the student's email through the access_token and returns it.
def get_student_email(access_token):
    if access_token is None:
        return None
    try:
        request = urlopen(INFO_ENDPOINT.format(access_token), timeout=3)
        user_data = json.loads(request.read().decode("utf-8"))
        user_email = user_data["email"]
    except IOError as e:
        user_email = None
    return user_email

def get_identifier():
    """ Obtain anonmyzied identifier."""
    token = authenticate(False)
    student_email = get_student_email(token)
    if not student_email:
        return "Unknown"
    return hashlib.md5(student_email.encode()).hexdigest()

if __name__ == "__main__":
    print(authenticate())
PK     ,}ÔH`aÜu  u     client/utils/assess_id_util.pyimport re

DICT_PROMPT_TO_CHARACTER = {
    '>>>': '#',
    'scm>': ';',
}

def canonicalize(assess_id):
    """
    Takes an assessment/question's ID and canonicalizeicalizes it across iterations of
    a course.
    """
    
    hash_regex = re.compile(r'\w{32}')
    
    lines = assess_id.split('\n')
    canon_lines = []
  
    parsing_code = False
    for line in lines:
        line = line.strip()

        if not parsing_code and len(line) > 0:
            for prompt in DICT_PROMPT_TO_CHARACTER:
                if line.startswith(prompt):
                    parsing_code = True
                    comment_character = DICT_PROMPT_TO_CHARACTER[prompt]
                    break

        # If False still in preamble and do not include in canonicalized lines
        if parsing_code:
            # Remove any comments
            comment_index = line.find(comment_character)
            if comment_index >= 0:
                line = line[0:comment_index].strip()

            # If a hashed answer, replace with constant since these vary by semester
            if hash_regex.match(line):
                line = 'LOCKED_ANSWER'

            # Remove any '# locked' text since these are here regardless of language
            if line == '# locked':
                line = ''

            if len(line) > 0:
                canon_lines.append(line)

    return '\n'.join(canon_lines) + '\n'
PK     ,}ÔHÒu8€"  "     client/utils/timer.py"""Timeout mechanism."""

from client import exceptions
import threading
import traceback

def timed(timeout, fn, args=(), kargs={}):
    """For a nonzero timeout, evaluates a call expression in a separate thread.
    If the timeout is 0, the expression is evaluated in the main thread.

    PARAMETERS:
    fn      -- function; Python function to be evaluated
    args    -- tuple; positional arguments for fn
    kargs   -- dict; keyword arguments for fn
    timeout -- int; number of seconds before timer interrupt

    RETURN:
    Result of calling fn(*args, **kargs).

    RAISES:
    Timeout -- if thread takes longer than timeout to execute
    Error   -- if calling fn raises an error, raise it
    """
    if timeout == 0:
        return fn(*args, **kargs)

    submission = __ReturningThread(fn, args, kargs)
    submission.start()
    submission.join(timeout)
    if submission.is_alive():
        raise exceptions.Timeout(timeout)
    if submission.error is not None:
        raise submission.error
    return submission.result

class __ReturningThread(threading.Thread):
    """Creates a daemon Thread with a result variable."""
    def __init__(self, fn, args, kargs):
        super().__init__()
        self.daemon = True
        self.result = None
        self.error = None
        self.fn = fn
        self.args = args
        self.kargs = kargs

    def run(self):
        try:
            self.result = self.fn(*self.args, **self.kargs)
        except Exception as e:
            e._message = traceback.format_exc(limit=2)
            self.error = e

PK     ,}ÔHkªqã         client/utils/sanction/client.pyfrom warnings import warn
warn('sanction.client.Client is deprecated, please use sanction.Client')
from sanction import Client
PK     ,}ÔHÓo„™!  !  !   client/utils/sanction/__init__.py# vim: set ts=4 sw=)

from functools import wraps
from json import loads
from datetime import datetime, timedelta
from time import mktime
try:
    from urllib import urlencode
    from urllib2 import Request, urlopen
    from urlparse import urlsplit, urlunsplit, parse_qsl

    # monkeypatch httpmessage
    from httplib import HTTPMessage
    def get_charset(self):
        try:
            data = filter(lambda s: 'Content-Type' in s, self.headers)[0]
            if 'charset' in data:
                cs = data[data.index(';') + 1:-2].split('=')[1].lower()
                return cs
        except IndexError:
            pass

        return 'utf-8'
    HTTPMessage.get_content_charset = get_charset 
except ImportError: # pragma: no cover
    from urllib.parse import urlencode, urlsplit, urlunsplit, parse_qsl
    from urllib.request import Request, urlopen


class Client(object):
    """ OAuth 2.0 client object
    """

    def __init__(self, auth_endpoint=None, token_endpoint=None,
        resource_endpoint=None, client_id=None, client_secret=None,
        token_transport=None):
        """ Instantiates a `Client` to authorize and authenticate a user

        :param auth_endpoint: The authorization endpoint as issued by the
                              provider. This is where the user should be
                              redirect to provider authorization for your
                              application.
        :param token_endpoint: The endpoint against which a `code` will be
                               exchanged for an access token.
        :param resource_endpoint: The base url to use when accessing resources
                                  via `Client.request`.
        :param client_id: The client ID as issued by the provider.
        :param client_secret: The client secret as issued by the provider. This
                              must not be shared.
        """
        assert token_transport is None or hasattr(token_transport, '__call__')

        self.auth_endpoint = auth_endpoint
        self.token_endpoint = token_endpoint
        self.resource_endpoint = resource_endpoint
        self.client_id = client_id
        self.client_secret = client_secret
        self.access_token = None
        self.token_transport = token_transport or transport_query
        self.token_expires = -1
        self.refresh_token = None

    def auth_uri(self, redirect_uri=None, scope=None, scope_delim=None, 
        state=None, **kwargs):

        """  Builds the auth URI for the authorization endpoint

        :param scope: (optional) The `scope` parameter to pass for
                      authorization. The format should match that expected by
                      the provider (i.e. Facebook expects comma-delimited,
                      while Google expects space-delimited)
        :param state: (optional) The `state` parameter to pass for
                      authorization. If the provider follows the OAuth 2.0
                      spec, this will be returned to your `redirect_uri` after
                      authorization. Generally used for CSRF protection.
        :param **kwargs: Any other querystring parameters to be passed to the
                         provider.
        """
        kwargs.update({
            'client_id': self.client_id,
            'response_type': 'code',
        })

        if scope is not None:
            kwargs['scope'] = scope

        if state is not None:
            kwargs['state'] = state

        if redirect_uri is not None:
            kwargs['redirect_uri'] = redirect_uri

        return '%s?%s' % (self.auth_endpoint, urlencode(kwargs))

    def request_token(self, parser=None, redirect_uri=None, **kwargs):
        """ Request an access token from the token endpoint.
        This is largely a helper method and expects the client code to
        understand what the server expects. Anything that's passed into
        ``**kwargs`` will be sent (``urlencode``d) to the endpoint. Client
        secret and client ID are automatically included, so are not required
        as kwargs. For example::

            # if requesting access token from auth flow:
            {
                'code': rval_from_auth,
            }

            # if refreshing access token:
            {
                'refresh_token': stored_refresh_token,
                'grant_type': 'refresh_token',
            }

        :param parser: Callback to deal with returned data. Not all providers
                       use JSON.
        """
        kwargs = kwargs and kwargs or {}

        parser = parser or _default_parser
        kwargs.update({
            'client_id': self.client_id,
            'client_secret': self.client_secret,
            'grant_type': 'grant_type' in kwargs and kwargs['grant_type'] or \
                'authorization_code'
        })
        if redirect_uri is not None:
            kwargs.update({'redirect_uri': redirect_uri})

        # TODO: maybe raise an exception here if status code isn't 200?
        msg = urlopen(self.token_endpoint, urlencode(kwargs).encode(
            'utf-8'))
        data = parser(msg.read().decode(msg.info().get_content_charset() or
            'utf-8'))

        for key in data:
            setattr(self, key, data[key])

        # expires_in is RFC-compliant. if anything else is used by the
        # provider, token_expires must be set manually
        if hasattr(self, 'expires_in'):
            try:
                # python3 dosn't support long
                seconds = long(self.expires_in)
            except:
                seconds = int(self.expires_in)
            self.token_expires = mktime((datetime.utcnow() + timedelta(
                seconds=seconds)).timetuple())

    def refresh(self):
        self.request_token(refresh_token=self.refresh_token,
            grant_type='refresh_token')

    def request(self, url, method=None, data=None, headers=None, parser=None): 
        """ Request user data from the resource endpoint
        :param url: The path to the resource and querystring if required
        :param method: HTTP method. Defaults to ``GET`` unless data is not None
                       in which case it defaults to ``POST``
        :param data: Data to be POSTed to the resource endpoint
        :param parser: Parser callback to deal with the returned data. Defaults
                       to ``json.loads`.`
        """
        assert self.access_token is not None
        parser = parser or loads 

        if not method:
            method = 'GET' if not data else 'POST'

        req = self.token_transport('{0}{1}'.format(self.resource_endpoint, 
            url), self.access_token, data=data, method=method, headers=headers)

        resp = urlopen(req)
        data = resp.read()
        try:
            return parser(data.decode(resp.info().get_content_charset() or
                'utf-8'))
            # try to decode it first using either the content charset, falling
            # back to utf-8

        except UnicodeDecodeError:
            # if we've gotten a decoder error, the calling code better know how
            # to deal with it. some providers (i.e. stackexchange) like to gzip
            # their responses, so this allows the client code to handle it
            # directly.
            return parser(data)


def transport_headers(url, access_token, data=None, method=None, headers=None):
    try:
        req = Request(url, data=data, method=method)
    except TypeError:
        req = Request(url, data=data)
        req.get_method = lambda: method

    add_headers = {'Authorization': 'Bearer {0}'.format(access_token)}
    if headers is not None:
        add_headers.update(headers)

    req.headers.update(add_headers)
    return req


def transport_query(url, access_token, data=None, method=None, headers=None):
    parts = urlsplit(url)
    query = dict(parse_qsl(parts.query))
    query.update({
        'access_token': access_token
    })
    url = urlunsplit((parts.scheme, parts.netloc, parts.path,
        urlencode(query), parts.fragment))
    try:
        req = Request(url, data=data, method=method)
    except TypeError:
        req = Request(url, data=data)
        req.get_method = lambda: method

    if headers is not None:
        req.headers.update(headers)

    return req


def _default_parser(data):
    try:
        return loads(data)
    except ValueError:
        return dict(parse_qsl(data))
PK     ,}ÔH»ïŸ»í   í              ¤    __main__.pyPK     FIz~R†  †             ¤  client/exceptions.pyPK     FI¾Õ²ëà   à              ¤Î  client/__init__.pyPK     Ü¥êHª¹ÕH©  ©             ¤Þ  client/protocols/unlock.pyPK     ,}ÔHòÄ“Ü	  	             ¤¿%  client/protocols/scoring.pyPK     ,}ÔHYÒTSr  r             ¤2  client/protocols/restore.pyPK     c·ÿH­;Oð5(  5(             ¤¬B  client/protocols/hinting.pyPK     ,}ÔHù ©ô¼	  ¼	             ¤k  client/protocols/grading.pyPK     ,}ÔH                       ¤u  client/protocols/__init__.pyPK     ,}ÔHåÀkÓç  ç             ¤Iu  client/protocols/export.pyPK     ,}ÔH¥÷‚y  y  !           ¤h  client/protocols/file_contents.pyPK     c·ÿH0›|  |             ¤ ”  client/protocols/autostyle.pyPK     ,}ÔH&éÂ†               ¤×¤  client/protocols/lock.pyPK     c·ÿHVëà×Ž%  Ž%             ¤¨  client/protocols/backup.pyPK     c·ÿH­4Ó"Ô  Ô             ¤ØÍ  client/protocols/analytics.pyPK     ,}ÔH            #           ¤çé  client/protocols/common/__init__.pyPK     ,}ÔHL°  °  !           ¤(ê  client/protocols/common/models.pyPK     ,}ÔHVAµæ#  æ#             ¤í  client/api/assignment.pyPK     ,}ÔH                       ¤3 client/api/__init__.pyPK     ,}ÔH                       ¤g client/sources/__init__.pyPK     ,}ÔHù:kT    &           ¤Ÿ client/sources/scheme_test/__init__.pyPK     ,}ÔH»èÄ6
  
  $           ¤ú client/sources/scheme_test/models.pyPK     ,}ÔHOOöl•
  •
  "           ¤F+ client/sources/doctest/__init__.pyPK     ,}ÔHžZÉ  É              ¤6 client/sources/doctest/models.pyPK     ,}ÔHº;l¥  ¥  "           ¤"F client/sources/common/importing.pyPK     ,}ÔHªì_«,  «,  $           ¤H client/sources/common/interpreter.pyPK     ,}ÔHœ-2˜¿  ¿             ¤ôt client/sources/common/core.pyPK     ,}ÔH            !           ¤î client/sources/common/__init__.pyPK     ,}ÔHÅ)ï`€
  €
  "           ¤- client/sources/common/pyconsole.pyPK     ,}ÔHúÙ«0	  0	             ¤íš client/sources/common/models.pyPK     egÖHŸ°´Ó§	  §	             ¤Z¤ client/sources/ok_test/wwpp.pyPK     ,}ÔHp!býÙ  Ù              ¤=® client/sources/ok_test/scheme.pyPK     ,}ÔHô¿™ë”  ”              ¤T» client/sources/ok_test/sqlite.pyPK     ,}ÔH¾BA7  7  !           ¤&Ó client/sources/ok_test/doctest.pyPK     èIl†óÔ  Ô  "           ¤œß client/sources/ok_test/__init__.pyPK     ,}ÔHg–ñs5  5              ¤°æ client/sources/ok_test/models.pyPK     ,}ÔH!Bž‡e  e  !           ¤# client/sources/ok_test/concept.pyPK     ¶’IÏå$©²
  ²
             ¤Ç client/sources/ok_test/logic.pyPK     FI                       ¤¶ client/cli/__init__.pyPK     FIw’Àˆ;  ;             ¤ê client/cli/ok.pyPK     ,}ÔH‹Û6V  V             ¤S< client/cli/common/messages.pyPK     ,}ÔH                       ¤ä= client/cli/common/__init__.pyPK     c·ÿHõL¯Ú               ¤> client/utils/format.pyPK     ,}ÔHö ¨ð0  0             ¤kL client/utils/software_update.pyPK     ,}ÔHÅë=B6	  6	             ¤ØX client/utils/html.pyPK     ,}ÔH5Ðtà   à              ¤@b client/utils/locking.pyPK     ,}ÔHaÞÈ ©  ©             ¤Uc client/utils/output.pyPK      ½ÝH~	&‹<  ‹<             ¤2l client/utils/guidance.pyPK     ,}ÔHêñÜ%/  /             ¤ó¨ client/utils/network.pyPK     ,}ÔH                       ¤W® client/utils/__init__.pyPK     c·ÿH¤%[²¯,  ¯,             ¤® client/utils/auth.pyPK     ,}ÔH`aÜu  u             ¤nÛ client/utils/assess_id_util.pyPK     ,}ÔHÒu8€"  "             ¤á client/utils/timer.pyPK     ,}ÔHkªqã                 ¤tç client/utils/sanction/client.pyPK     ,}ÔHÓo„™!  !  !           ¤0è client/utils/sanction/__init__.pyPK    7 7 Þ  p	   
